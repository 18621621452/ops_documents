第一章 计算机工作原理
1.1 现代计算机五大部件
	运算器
	控制器
	存储器
	输入设备
	输出设备
1.1.1 计算机各部件的功用
	运算器是用来做计算的，只能做二进制计算，做简单的算术运算和逻辑运算。如加、减、乘、除、取模等等。运算器的核心就是一个加法器。
	控制器是用来控制计算机各部件之间的协调的。
	比如运算器要想做运算，必须先把数据从存储器中取出来，交给运算器计算以后再在存储器中找一块空闲的存储单元把计算后的结果给存储起来。而这仅仅是控制器的工作之一。
	现代计算机已经将运算器和控制器合二为一，就是我们所熟知的中央处理器（CPU）。
	人的大脑有存储记忆的能力，但是计算机不行，计算机要想存储记忆则需要一个部件来实现。运算器是一个部件、控制器是一个部件、存储器也是一个部件，而部件与部件之间的数据交换则需要通过线路来实现，也就是接下来要说的总线（bus）。
	现代计算器有三种总线，分别是控制总线、数据总线、地址总线。
	地址总线的功能是实现寻址。那么什么是寻址呢？
	数据是存储在存储器中的，而运算器要想运算则必须通过控制器将数据从存储器上调出来再进行运算，运算完以后还要把结果给存储到存储器中。那么控制器怎么知道要运算的数据是存储在存储器的哪个存储单元中呢？我们先来说说存储器。
	存储器（Memory）是一种编址存储设备。
	插入内存条图片
	如图所示，存储器中每8位（8bit=1Byte）为一个存储单元，每个存储单元（8bit）可以存储8bit数据。存储器就是由众多的存储单元组成的一个整体的存储空间。
	我们把数据存储在存储器中，我们需要的时候要在存储器中找到它，而这个找到存储器中数据的过程就是寻址。
	存储器中的每一个存储单元都是有地址的，那么这个地址能有多少种变化形式呢？
	计算机只能识别二进制，所以存储器是通过二进制进行编址的。如果我们要使用4G内存空间，那么就需要2的32次方bit来进行编址。
	之所以32位操作系统只支持4G内存空间就是因为其只有32根地址总线，每根总线只能表示0和1两种数字。所以我们要表示4G种变化，就需要32个二进制数字排在一块，一直从00000000000000000000000000000000到11111111111111111111111111111111，这中间有4294967296种变化。假如你的计算机是64位的，那么就有2的64次方种变化。
1.1.2 I/O设备
	I/O设备已经不算计算机的核心部件了，I/O存在的目的是为了与外部交互。
	假如CPU和内存是一个自循环系统，不需要与外部交互，其所有的工作都能在其内部完成，那么就不需要I/O设备了。但这是不可能的。
	由于内存是一种易失性存储器，断电后其所有内容会丢失。另外计算机还需要跟其他计算机进行交互，这些都需要用到I/O设备。
	I/O设备说白了就是一个与外部部件（如磁盘、网卡、键盘、鼠标等）进行交互的组件。
	I/O设备通常是最慢的设备。
1.1.3 主板
	计算机内各部件需要通过线缆给连接起来，如果弄一大堆线缆就非常麻烦了，不好整理，于是就有了主板（motherboard）。主板就负责把计算机内各部件给连接起来。
1.1.4 传统硬盘
	传统硬盘是一种固定角度的设备。硬盘是有盘片的，盘片上面有磁条，磁条悬浮在盘片上面，大约5微米的间隙。通过磁盘碰触盘片的方式读写数据。
	硬盘从外向内分了很多磁道，一个盘片2面都能读写，不同盘面上面，相同磁道的编号我们称之为柱面。分区就是按柱面由内向外进行的。

1.2 缓存
	如果存储器与运算器之间的操作一个快一个慢的话，最终速度取决于慢的操作。那么为什么会有快慢的概念呢？
	很多人可能知道，CPU是有时钟频率的，时钟频率是指其在单位时间内电频可以变化的次数。4GHz指的是在1秒内能够变化40多亿次，这也就意味着1秒内可以完成40多亿bit数据的传输。
	众所周知，现代的CPU工作速率很高，动辄3GHz是很常见的。但是内存通常是1500MHz、1866MHz。其速率比起CPU来说要慢很多。而数据处理的速度是以慢的为准，假如内存处理的速度过于缓慢的话就很影响计算机处理的效率，为了解决这个问题，缓存应运而生。
	CPU有一级缓存、二级缓存、三级缓存等，这些缓存的工作方式很独特，其能以几乎接近CPU工作频率的速度来工作，但是其造价非常高，所以缓存空间一般都很小。
	缓存能够极大的加速CPU与内存的交互，因为计算机程序的运行具有局部性的特性。通常数据有两种局部性，分别是空间局部性和时间局部性。
1.2.1 数据的局部性
	如果你访问一个数据，离这个数据很近的其他数据也可能很快就会被访问到，所以加载数据的时候就把其后面的数据提前加载好，这就是预取（read ahead）。先把其加载到缓存中去，等用到的时候由CPU直接去缓存中取。如此就不必等CPU去内存中取，速度就加快了很多。此为数据的空间局部性。
	刚刚访问过的数据，过一会可能还会被访问到，把多次需要用到的数据放到缓存中，等需要的时候就不必去内存中取。此为数据的时间局部性。

1.3 CPU工作原理
	CPU被逻辑切割成N个时间片，让每个程序在CPU中执行一段时间，假定是5毫秒，不管程序是否执行完毕，均使其退出并记录执行状态。
	假如有2个程序需要同时运行，第1个程序执行5毫秒以后，由CPU中止其运行，并记录其运行到哪里了，然后将第2个程序放到CPU中运行，运行5毫秒以后，由CPU中止其运行，并记录其运行到哪里了，然后将第1个程序调到CPU中，从上次运行结束的位置继续执行该程序，以此类推。通过这种分时机制实现多任务同时运行的目的。

	前面已经说过了，CPU是由运算器和控制器组成的，且只能运行二进制指令。那么CPU能够进行什么运算取决于什么呢？CPU为什么能够执行运算？
	插入CPU图
	CPU有很多针脚，每根针脚对应不同的功能。CPU的运算其实就是由控制器到存储器中取出数据和运算符，并在CPU中找到该运算符所对应的针脚，调用该针脚的功能的过程。
	每个CPU的功能都通过CPU的指令来实现，多个CPU指令联合起来我们称之为CPU指令集。同一颗CPU当中，为了完成不同的运算功能，很多时候可能由多个不同的芯片组成。比如完成多媒体处理和完成整数运算那是两回事，完全是由2个不同的芯片完成的。同一个CPU内部，可能有多种功能上各自独立的芯片，而且每一组芯片提供的运算能力和指令都不一样。所以，同一个CPU内部所能够提供的指令集有很多。不同厂商的CPU指令集的功能可能各不相同。

	cpu的指令集中的指令分为两种：
	a) 特权指令（拥有管理功能，只能被操作系统调用）
	b) 普通指令
	一般来说，程序员写的程序只能调用普通指令，只有操作系统才能够调用特权指令。
	插入cpu环的图片
	如上图所示，CPU生产厂商把整个CPU所能够实现的指令集分成了4个环，环0所包含的指令都是特权指令，只有操作系统才有权限去运行。所有的普通指令都在环3上，出于历史原因，环1和环2没有使用。
	操作系统运行时通常运行环0和环3中的指令，而应用程序只能运行环3上的指令。但是有些应用程序可能要做管理操作，比如要在系统中创建一个目录（mkdir命令），这个目录要存储在硬盘上，而操作硬盘写数据就属于特权指令，只有操作系统才有权限执行。
	任何情况下，一个普通程序要想完成一个特权操作，是没办法直接进行的，它必须向内核申请。


1.4 内存工作原理
	内存的存储空间是固定的。如果有10个程序需要运行，第一个程序占据了一部分内存，第二个程序有可能把第一个程序的内存给覆盖了，这就是内存溢出。内存溢出是不被允许的，所以我们必须把有限的内存给逻辑切割以后分配给多个程序使用。
	现代计算机中的内存存储空间本来就是虚拟的，给每个程序分配的空间都是假的。在程序看来自己是唯一的，程序看不到其他的程序。假定其运行在一根512M的内存上，但程序却可以认为其有4G内存空间可用。但事实上其所能用的空间可能仅仅就是几M，多则几十M。这种就称之为线性地址空间。


第二章 计算机编程
2.1 编程语言
	从本质上来说，CPU只能运行二进制格式的指令，也就是CPU内指令集限定的二进制指令。
	如果让程序员通过二进制进行编程，那就太困难了，很少有人能够通过二进制进行编程。但是人类又需要很多人能够进行编程，所以必须让编程代码能够接近人类所能理解的思维方式才行。所以编程语言有所谓高级语言和低级语言之分。
	一种编程语言离机器越近我们就说它越低级，离人越近我们就说它越高级。高级并不是说功能强，也不是指性能强大，而是指它越接近于人类的自然语言。
	高级语言人类容易看懂了，但是计算机看不懂，所以要想使用高级语言写的程序能够在CPU中执行，必须先将其转换成CPU所能够理解的二进制指令。
	插入机器与人的图片
	如图所示，从机器到人之间通常有三层，分别为机器语言-->汇编语言（微码语言）-->高级语言。
2.1.1 高级语言编写的程序的执行过程
	用高级语言编写的程序要想执行通常有2个过程：
	a) 把高级语言转换成汇编语言（转换成对应的CPU芯片所支持的汇编语言）
	b) 把汇编语言转换成对机器指令的调用
	如果是C语言，第一步我们称之为编译的过程。
	从高级语言转换成汇编语言的过程取决于底层的CPU芯片是什么格式的。不同厂商所生产的不同型号的CPU是不一样的。
2.1.2 编程语言的使用场景
	汇编语言（微码编程）：用于编写系统中某些与硬件相关的特有代码、驱动程序开发等
	高级语言C，C++：用于编写系统级应用、对性能要求非常高的应用、驱动程序开发等
	高级语言java，python，php：用于开发应用程序

2.2 通用软件
2.2.1 通过软件的背景
	上面已经说过，不同厂商生产的CPU，其内含的指令集是不一样的。同样，一个程序在512M内存中运行和在4G内存中运行，其所能够使用的内存资源也是不一样的。因此写程序时必须要告诉程序有多少内存资源可以用，任何一个程序员写任何一个程序都要考虑底层的机器是谁，是什么厂商的芯片，运行的速度如何，拥有多少资源等等。写一个程序是512M内存的，就只能在512M内存的机器上运行，稍微换一个就不行了。这是非常麻烦的，因此，我们要达到灵活使用的目的，就必须将这些底层的差异给消除。那么如何消除这些底层的差异呢？
	比如我们要去很多个国家旅游，每个国家的语言都不一样，若想独自旅行就要学多种语言，若我们不会这些国家的语言就可以找个懂这些国家语言的翻译随行。
	同理，为了避免程序员写程序时要应付各种机器的不同情况，就找了一个翻译，它本身能够应付各种底层的不同情况，但是向上输出的接口是统一的。这就是通用软件。
	插入通用软件图片
	通用软件是一种将底层计算机所提供的各种计算能力给抽象为一种统一接口的程序。无论底层是AMD的CPU还是Intel的CPU，都可以统一成一种提供计算能力的接口。无论内存是多少G的，统一规定32位系统最多支持4G内存，64位系统最多支持4G个4G的内存。
	有了通用软件（操作系统）以后，程序员写程序就不用考虑底层的实现了，只需要针对操作系统的接口进行编程。如此一来就大大的简化了编程的过程，效率自然提高了。
2.2.2 OS（Operation System）
	OS是一种通用软件程序。
	在上一章我们说过，任何情况下，一个普通程序要想完成一个特权操作，是没办法直接进行的，它必须向内核申请。
	当系统运行起来以后，操作系统随时监控在特权指令上，一旦发现有要执行特权指令的程序，只能向操作系统发请求，由操作系统代理完成特权操作。所以操作系统必须能够随时接收程序发来的请求。那么操作系统允许接收以下请求：
		a) 硬件驱动
		b) 进程管理
		c) 内存管理
		d) 网络管理
		e) 安全管理
	每一个被操作系统所允许接收的请求，都称之为系统调用（System Call）。

2.3 编程层次
	硬件规格（hardware specifiacation）：面向硬件编程
	系统调用（system call）：面向操作系统编程
	库调用（library call）：把非常多的底层功能整合出来，提供成离最终目标更近的功能
	程序员写程序要么面向硬件规格，要么面向操作系统。而操作系统又过于底层，于是就有人把操作系统向上又抽象出来一层，也就是上面所说的库调用。此时程序员编程的过程就简化多了。
2.3.1 ABI与API
	众所周知，windows下的应用程序拿到Linux下是无法运行的。
	一个应用程序一旦制作成了二进制格式，其适用的操作系统平台也就定下来了。编译成了exe格式的就只能在windows下运行，编译成了tar.gz格式的就只能在类Unix的系统下运行。这是由应用二进制接口规定的，也就是ABI（Application Binary Interface）
	ABI是一种操作系统接口格式，是一种规范，定义了系统平台所属。
	面向不同操作系统的应用程序，编译成二进制格式以后在不同平台是无法兼容的。但是在没有编译的情况下，如果应用程序的源代码是针对不同平台的相同接口进行编写的，那么该源程序就可以跨平台编译。也就是说源程序可以在windows下编译，也可以在类Unix系统下编译，编译后的二进制程序格式是不一样的。
	这里说的不同平台的相同接口，这个接口是指应用编程接口API（Application Programming Interface）。
	API是一种应用编程接口，程序员一般都是针对API进行编程。
	windows和linux的应用程序格式不一样，但是编程接口API却是可以兼容的。这也就意味着，程序员在windows系统下以兼容模式写的程序源代码在linux下是兼容的。虽然源代码是兼容的，但是一旦编译成了二进制格式，若是在linux下编译的就只能在linux下运行，若是在windows下编译的就只能在windows下运行。
	面向库的编程时，程序员写应用程序源代码是面向API进行的，一旦编译成二进制格式了，就是面向ABI了。
2.3.2 UI（User Interface）
	GUI（Graphic User Interface）：图形用户接口，如windows桌面
	CLI（Command Line Interface）：命令行接口，如Unix/Linux下的命令行终端

第三章 Linux基础知识
3.1 程序的组成与执行过程
3.1.1 三种编程接口
	在前面几章我们已经粗略的说过，面向计算机通常有三种编程接口，分别是：
	a) 硬件规格
	b) 系统调用
	c) 库调用
	每个CPU的生产厂商在生产一个计算芯片时，这个芯片本身有其内置的指令集，所以有一部分人在编程时直接面向这些指令集进行，这类编程方式就是面向硬件规格编程。
3.1.2 程序执行过程
	前面我们说过，Intel x86系列的CPU，通常由外而内，指令集是分布在4个环上的，环0上的是特权指令，只能由操作系统执行，环3上的是普通指令，可以由程序执行也可以由操作系统执行。那么程序的执行过程到底怎样？这里举个例子说明一下：
	比如我们要计算1+1，计算1+1这条指令并不需要什么特权，程序可以直接执行，但是需要注意的是，要执行1+1需要在内存中取得加数、被加数与加号“+”，而应用程序是无法与内存直接交互的。此时就需要执行系统调用了，第一次系统调用在内存中取出加数，第二次系统调用在内存中取出被加数，第三次系统调用取出加号“+”，剩余的运算才不需要特权指令，才不需要系统调用参与而直接由应用程序执行。
	一个程序的运行大多有一部分是普通指令，由内核分配给cpu运行，还有一部分是特权指令，由程序向操作系统发起系统调用，最后由操作系统完成操作并返回结果给程序。一个程序的运行过程大体就是这样，下图是程序运行过程的一张图，可以参考参考。
	插入程序运行过程的图
3.1.3 程序运行模式
	如图1所示，因为一个程序的执行大多有两部分组成（特权指令与普通指令），所以一个程序的运行大体分为两个模式，分别是用户模式与内核模式，也称作用户空间（User Space，简称us）和内核空间（System space）
	并非系统调用在每个时刻都会发生，因为程序的普通指令是允许直接在CPU上运行的，但特权指令是不允许程序直接在CPU上运行的，必须由操作系统来代理完成。因为现代操作系统一般都是多用户多任务的，CPU只有一个，同一时间只能由一个程序执行，程序1占据了CPU程序2就无法执行，所以为了防止此类现象的发生，才有了内核，由内核来指挥程序运行，而所有的特权指令由操作系统（内核）自己来代理完成。
3.1.4 程序的组成
	程序一般由指令+数据组成，其中指令就是cpu内置的指令，它是不可变化的。而数据是由用户提供的，是指令加工的对象，数据是可读写的。
	从另一个角度来说，程序是由算法+数据结构组成的。写程序无法是设计数据结构，并设计算法对数据进行加工。算法其实就是CPU的内置指令按照一定的逻辑去运行。

3.2 可移植操作系统规范POSIX
	由于直接面向系统调用进行编程过于底层，使编程难度极大增加，于是就有人将这些非常底层与原始的系统调用再次向上抽象了一层，也就是我们所说的库调用。现在的程序员一般大多数情况下是基于库调用和一部分系统调用来研发的，无论是windows还是linux大多数都是基于C语言研发的，所以其库一般都是C库。无论是windows还是linux系统都提供了库，如果两者的库不兼容，会导致在windows上写的程序在linux上没法用，于是国际电子电气工程师协会IEEE（Institute of Electrical and Electronics Engineers）对库的标准定义了一种规范，也就是这节我们要说的可移植操作系统规范POS（Portable Operating System）。有了POS以后，无论在任何平台下写程序，只要程序遵循POS规范，那么其源码在不同平台下是可以兼容的。但是POS这个名字跟约定俗成的Unix、Linux不太像，后来就把POS给改成了POSIX。
	事实上，从windows server 2003以后的windows版本和绝大多数的linux、unix版本，其库均是遵循POSIX规范的。

3.3 操作系统程序的接口格式
3.3.1 程序的运行格式
	Windows：EXE
	Linux：ELF
3.3.2 库格式
	Windows：dll（dynamic link library）
	Linux：so（share object）

3.4 垃圾回收机制GC（Garbage collection）
3.4.1 C语言特性
	C语言允许程序使用指针，可以直接操作内存空间，申请内存和释放内存都是由程序员手动进行的。
	malloc()：这是一个申请内存的系统调用
	free()：这是一个释放内存的系统调用
3.4.2 垃圾回收机制背景
	让我们来想一个问题，如果A程序运行中free了其他程序的内存空间会怎么样呢？如果程序多次申请内存空间，但是都不释放呢？这些都是不被允许的。因此C语言要求程序员必须精心设计内存的申请和回收，一旦设计有一点点不当，就可能导致程序出错，使程序间互相干扰。缓冲区溢出就是使用这种方式来实现的。
	C语言虽然是高级语言，但是其兼具一些低级语言的特性。C语言适用于写操作系统层级的程序和一些对性能要求非常高的程序，如Mysql。
	插入解释器与虚拟机图片
	基于C语言的特性，有人就把库调用又向上抽象了一层，就是高级语言的解释器或虚拟机，如python的命令行界面、java的jvm。这一层已经与操作系统内核没有任何关系了。在这一层写的程序需要用内存时只需要申请分配即可，用完不需要手动进行释放，虚拟机会自动监视程序使用内存的情况，发现有程序用完了的内存就收到一个垃圾桶里，等垃圾桶满了再统一释放。这个过程就是垃圾回收机制，此垃圾回收机制在python和java中都是通用的。
3.4.3 垃圾回收机制的缺陷
	有了垃圾回收机制以后，程序员写程序只需要申请分配内存，而无需手动释放内存，由虚拟机自动释放内存。如此一来就很难出现前面所说的一个程序覆盖其他程序的内存的情况了。
	垃圾回收机制大大的解放了程序员的精力，但是其也有其缺陷。由于虚拟机很难猜测程序申请的内存什么时候不需要使用了，而且程序很可能申请了众多内存空间并且用完以后不再用了。为了完成垃圾回收，垃圾收集器就必须定期、周期性的扫描内存空间，看哪些内存已经没有被使用了，将其标记为垃圾，达到一定阀值以后（比如内存只有100M，当垃圾达到40M时）再统一回收。而垃圾回收是非常占资源的，因为在进行垃圾回收时，其他程序的运行过程就被打断了。这也就是Android手机用起来卡的原因，因为Android手机就是运行在一个java虚拟机中的。

3.5 自由软件
	自由软件的特点：
	a) 可以自由使用（学习和修改）
	b) 可以自由分发
	c) 可以自由创建衍生版

3.6 Linux的哲学思想
	a) 一切皆文件（把几乎所有资源，包括硬件设备都组织为文件格式）
	b) 由目的单一的小程序组成，一个程序只实现一个功能，组合小程序完成复杂任务
	c) 尽量避免捕获用户接口（为实现脚本编程打下了基础，可以自动完成某些功能）
	d) 配置文件保存为纯文本格式（用文本编辑器即可完成系统配置工作）

3.7 获取发行版的方式
	a) http://mirrors.aliyun.com
	b) http://mirrors.sohu.com
	c) http://mirrors.163.com

3.8 终端与交互式接口
3.8.1 终端
	终端是用户与主机交互必然要用到的设备。
	终端分为以下几类：
	a) 物理终端：直接接入本机的显示器和键盘设备，也称作控制台console
	b) 虚拟命令行终端：附加在物理终端之上的、以软件方式虚拟实现的终端。Centos 6默认启动6个虚拟终端
		可以用Ctrl+Alt+Fn(F1-F6)进行虚拟命令行终端间的切换
		设备文件路径：/dev/tty#
	c) 图形终端：附加在物理终端之上的、以软件方式虚拟实现的终端。但额外会提供桌面环境。
		图形终端是虚拟终端的一种，可以在启动过图形终端的情况下使用Ctrl+Alt+F7在虚拟命令行终端与图形终端间切换
	d) 模拟终端：附加在图形终端或远程终端下，纯软件实现的终端
		图形界面下打开的命令行接口，基于SSH协议或telnet协议等远程打开的界面
		设备文件路径：/dev/pts/#
	查看当前的终端设备命令：tty
3.8.2 交互式接口
	交互式接口是启动终端后，在终端设备附加的一个交互式应用程序
	交互式接口主要分为2种：图形用户终端与命令行终端
	GUI：
		X protocol,window manager,desktop
		Desktop:
			GNOME（C,gtk）
			KDE（C++,qt）
			XFCE（轻量级桌面）
	CLI：
		shell程序：
			sh（作者：bourn）
			csh
			tcsh：csh的升级版
			ksh（作者：korn）：商业版，闭源的应用程序
			bash（bourn again shell）：遵循GPL的开源应用程序，Linux领域目前最流行，各发行版的标准shell
			zsh
		显示当前使用的shell命令：
			echo $SHELL
		显示当前系统支持使用的所有shell：
			cat /etc/shells

3.9 命令
	输入命令，回车意味着什么？
		提请shell程序找到键入命令所对应的可执行程序或代码，并由其分析后提交给内核分配资源将其运行起来。运行起来以后表现为一个或多个进程。
	在shell中可执行的命令有两类：
		a) 内建命令：由shell自带的，通过某命令形式提供
		b) 外部命令：在当前系统的鞭文件系统路径下有对应的可执行程序文件。可使用which或whereis查询可执行程序文件的位置
		区别内部或外部命令：
			type COMMAND
	运行命令：
		命令格式：
			COMMAND [OPTIONS...] [ARGUMENTS...]
				选项（OPTIONS）：用于启用或关闭命令的某个或某些功能
				参数（ARGUMENTS）：命令的作用对象，向命令提供数据

第四章 bash的特性
4.1 bash的特性：
	a) 支持命令历史、命令补全；
	b) 支持管道、重定向；
	c) 支持命令别名；
	d) 支持命令行编辑；
	e) 支持命令行展开；
	f) 支持文件名通配；
	g) 支持变量；
	h) 支持编程

4.2 bash支持的引号：
	``：命令替换
	""：弱引用，可以实现变量替换
	''：强引用，不完成变量替换

4.3 命令行编辑：
4.3.1 光标跳转：
	Ctrl+a：跳到命令行首
	Ctrl+e：跳到命令行尾
	Ctrl+u：删除光标至命令行首的内容
	Ctrl+k：删除光标至命令行尾的内容
	Ctrl+<--：光标定位到离自己最近的一个单词前面
	Ctrl+l：清屏
4.3.2 命令历史：
	history：查看命令历史
	    -c：清空命令历史
        -d OFFSET ［n］：删除指定位置的命令历史
        -w：保存命令历史至历史文件～/.bash_history中
	命令历史的使用技巧：
		!n：执行命令历史中的第n条命令
		!-n：执行命令历史中倒数第n条命令
		!!：执行上一条命令
		!string：执行命令历史中最近一个以指定字符串开头的命令
		!$：引用前一个命令的最后一个参数
		esc,.：按下esc松开后按.，引用前一个命令的最后一个参数
	控制命令历史的记录方式：
		环境变量：HISTCONTROL
			ignoredups：忽略重复的命令（连续且相同方为“重复”）
			ignorespace：忽略所有以空格开头的命令，如“  ls -l”
			ignoreboth：ignoredups和ignorespace均生效
		修改环境变量HISTCONTROL值的方式：export HISTCONTROL=ignoreboth
4.3.3 命令补全：搜索PATH环境变量所指定的每个路径下以我们给出的字符串开头的可执行文件，如果多于一个，两次tab，可以给出列表，否则将直接补全
4.3.4 路径补全：搜索我们给出的起始路径下的每个文件名，并试图补全
4.3.5 命令别名：    
	alias CMDALIAS='COMMAND [options] [arguments]'
    在shell中定义的别名仅在当前shell生命周期中有效，别名的有效范围为当前的shell进程。

4.4 命令替换：$(COMMAND)或`COMMAND`
    把命令中某个子命令替换为其执行结果的过程，就叫做命令替换

4.5 文件名通配：globbing
    *：匹配任意长度的任意字符
    ?：匹配任意单个字符
    []：匹配指定范围内的任意单个字符
            [abc]，[a-m]，[0-9]
            [[:space:]]    表示空白字符
            [[:punct:]]    表示标点符号
            [[:lower:]]    表示小写字母
            [[:upper:]]    表示大写字母
            [[:alpha:]]    表示大小写字母
            [[:digit:]]    表示数字
            [[:alnum:]]    表示数字和大小写字母
        使用man 7 glob命令可以获得以上字符集合的帮助信息！！！
    [^]：匹配指定范围之外的任意单个字符

4.6 环境变量：
    PATH：命令搜索路径
    HISTSIZE：命令历史缓冲区大小
    SHELL：当前shell
4.6.1 bash内置变量：
    RANDOM：保存着0-32768之间的随机数
	随机数生成器：熵池
		/dev/random：这里生成的随机数用尽时会阻塞用户进程，待生成更多的随机数里即恢复，比较安全
		/dev/urandom：这里生成的随机数用尽时会通过软件模拟生成更多的随机数进来，不会阻塞用户进程，比较好用

4.7 命令行展开
	~：展开为用户的主目录
	~USERNAME：展开为指定用户的主目录
	{}：可承载一个以逗号分隔的列表，并将其展开为多个路径
		/tmp/{a,b} ==> /tmp/a，/tmp/b

4.8 命令的执行结果状态
	bash使用特殊变量$?保存最近一条命令的执行状态结果
	程序执行以后有两类结果：
		a) 程序的返回值
		b) 程序的执行状态结果
	程序状态返回代码（0-255）：
		0：正确执行
		1-255：错误执行，1、2、127系统预留，有特殊意义

4.9 编程环境
	程序编程风格：
		过程式：以指令为中心，数据服务于指令
		对象式：以数据为中心，指令服务于数据

第五章 文件系统
5.1 根文件系统
	众所周知，在一块新的硬盘中安装系统前必须要先分区并且格式化，然后才能装系统。
	对于windows来说，分区完成以后，每个分区都是一个独立的文件系统。也就意味着C盘和D盘是毫无关系的。访问时也是各自独立的。
	对于linux来说，所有的文件在linux主机上，若想使其能够被访问到，站在逻辑结构视角上看，它必须从一个称为根文件系统的位置开始，但是并不是说所有文件必须从根开始就不需要分区了，并非如此。为了能够实现多个文件系统独立管理必须要进行分区。但是任何一个分区在分区完以后，不可以被独立访问，而是只能够与现有的根一起被访问。
	插入文件系统工作图
	当内核被启动加载完成以后，其不提供任何多余的可供用户访问的文件，同时其也不是可供用户直接使用的有用的进程。所以内核必须要能够启动很多外部命令，包括shell程序、各种GUI或者CLI接口等等。而这些命令通常一般都是放在某一分区之上。但是系统中有那么多分区，内核应该识别哪一个呢？为了避免这种选择上的困难，一般来说，无论分成多少个分区，一定有一个作为系统盘的分区存在，而这个系统盘分区通常是内核启动完以后第一个要加载的分区。
	如上图所示，假设A分区是系统盘分区，内核认为A分区是其必须第一个要加载的分区，于是当内核启动完以后，为了能够帮助启动各种外围的其他程序，内核会自行在自己的工作空间中设置一个路径，把它称作根。然后把A（系统盘）分区上的所有内容直接关联到根上。这也就意味着，如果要通过根路径来访问的任何文件其实都是在A分区上的文件。
	对于Linux来说，内核所能识别的第一个且必须第一个加载的文件系统就称作根文件系统（rootfs）。
	一旦A分区被内核认为是第一个要加载的分区，那么B分区、C分区、D分区如何被访问到？在windows中，A分区、B分区、C分区、D分区都是独立的，想访问哪个分区就直接去访问。而在linux中，除A（系统盘）分区以外的任何分区要想被访问到，必须与现有的根文件系统建立关联关系。

5.2 常见的文件系统
	常见的文件系统有以下这些：
        Linux文件系统：ext2、ext3、ext4、xfs、btrfs、reiserfs、jfs、swap
            swap：交换分区
            iso9660：光盘文件系统
            ext4：centos6主流的文件系统
            btrfs：centos7自带的文件系统
            xfs：centos7上推荐使用的文件系统
        Windows文件系统：fat32、ntfs
        Unix文件系统：FFS、UFS、JFS2
        网络文件系统：NFS、CIFS
        集群文件系统：GFS2、OCFS2
        分布式文件系统：ceph、moosefs、mogilefs、Glusterfs、Lustre
    根据其是否支持“Journal”功能又分为以下2种文件系统：
        日志型文件系统：ext3、ext4、xfs、...
            日志型文件系统存储时先在日志区写元数据，如果发生断电，可以通过日志进行恢复
        非日志型文件系统：ext2、vfat    
            非日志型文件系统存储时直接在元数据区写元数据，一旦断电，没写完的数据将损坏，只能删除然后重新操作
    文件系统的组成部分：
        内核中的模块：ext4、xfs、vfat等；
        用户空间的管理工具：mkfs.ext4、mkfs.xfs、mkfs.vfat等
    从上面的信息就可以看出来，Linux支持众多的文件系统，而每一个文件系统的调用接口又是不一样的，这对程序员来说就头疼了，如此多的文件系统，若想针对某文件系统进行编程，就必须了解众多文件系统的调用接口，这样一来就使得编程的难度大大增加。而事实上，程序员面对的并不是ext2等这类文件系统 ，而是虚拟文件系统（VFS）。VFS把所有文件系统不同的各种调用机制统一在同一个调用接口上了。所以程序员不管系统被格式化成什么格式的，只要支持VFS，就可以直接调用VFS接口，由VFS去转换成对特定类型的文件系统接口的调用。Linux众多的文件系统中，只要遵循POSIX文件系统规范的一般都能够被VFS所兼容。
    /proc/filesystems：当前内核支持的文件系统类型有哪些
        文件前面没有nodev的表示是正在使用的文件系统
    文件系统的配置文件/etc/fstab：
        OS在初始时，会自动挂载此文件中定义的每个文件系统。这个文件的内容格式为：
        要挂载的设备	挂载点	文件系统类型	挂载选项	转储频率    文件系统检测次序(只有根可以为1)
    要挂载的设备可以有以下几类：
    	设备文件：/dev/sda5
    	卷标：LABEL=""
    	UUID：UUID=""
    	伪文件系统名称：proc、sysfs、devtmpfs、configfs
    挂载点的要求：
        a) 此目录没有被其它进程使用
        b) 目录必须事先存在
        c) 目录中原有的文件将会暂时隐藏，卸载后可见
    转储频率：每多少天做一次完全备份，0表示不备份，1表示每天备份，2表示每2天备份1次
    注意：swap分区的挂载点和文件系统类型都是swap。如果要让文件系统自动挂载的同时启用某功能，比如要启用acl功能，只需要在挂载选项defaults后面加上,acl即可，如defaults,acl


5.3 ext文件系统的布局结构
5.3.1 数据区布局结构
插入ext文件系统架构图
任何一个文件系统都由数据和元数据组成，这里以ext系统文件系统为例。
如上图，数据区（数据空间）会被划分为一个个的块组，而每个块组当中又包含了超级块、块组描述符（GDT）、块位图（block bitmap）、Inode位图（inode bitmap）、Inode表（inode table）和数据块（data blocks）。
每个块组有多少个块取决于块的大小，为了方便定位块组中的块于是定义了一个超级块
超级块可以有多个备份，其内容如下：
	当前文件系统类型；
	当前文件系统包含多少个inode；
    当前文件系统共有多少个块；
    当前文件系统每个块的大小；
    空闲磁盘块、引用磁盘块、空闲inode、引用inode
使用tune2fs -l /dev/sda1命令可以看/dev/sda1的超级块信息。
块组描述符表（GDT）可以有多个备份，其内容如下：
	当前系统一共有多少个块组
	每个块组从第几个块开始到第几个块结束
使用dumpe2fs /dev/sda1命令不仅可以看到/dev/sda1文件系统的超级块信息，还可以看到块组描述符的信息。
5.3.2 元数据区
	元数据区包含以下内容：
		Inode表（存储inode）
		Inode bitmap（索引位图）
		Block bitmap（块位图）

	能够存储单个文件所有属性信息并以特定格式组织的存储空间就称为Inode。
	Inode就是索引节点（Index node）。Inode包含以下内容：
		文件/目录的大小；
		时间戳；
		权限；
		属主、属组；
		地址指针：文件使用了哪些块存储数据，用指针指向对应的数据块的编号
			直接指针（直接指向数据块）
			间接指针（指向另一个位置，另外一片连续的区域，象扩展分区一样）
			三级指针
	访问任何一个文件都要先找到其对应的inode，通过inode知道该文件的数据存储在哪些块中，然后找到对应的块。
	硬盘中的大多数块必须有其编号，并能够被inode引用，才可以正常使用。
	为了实现inode的快速存储，元数据区在格式化完成以后就已经把inode整个区间分好了，每个inode块的大小是固定的，只不过这些inode是空闲的，没被使用的。
	假设一个文件系统有100万个inode，那么如何区分inode是否空闲呢？
	我们假设每一个inode的前面有一个标志位，1表示已经使用，0表示空闲。当要使用时就必须全局扫描，找到第一个空闲的inode，然后把要存储inode信息填充其中。
	再假设数据区的每一个block块的前面也有一个标志位，1表示已经使用，0表示空闲。当要使用时也必须全局扫描，找到第一个空闲的block块，然后把数据填充其中并建立与对应inode的映射关系。
	假设一个文件很大，可能需要多个block块存储其数据，就必须为其分配多个连续的空闲块来存储，并将已使用的block的标志位设为1；
	假设一个文件很小，可能1个block块就可以存储其数据，就把其余多余的block标志位设为0
5.3.4 位图索引
	想一个问题，如果硬盘有100G，为了找一个空闲块就要全盘扫描一遍，这样的方式太低效了，为了解决这个问题于是就有了二级索引。
	由于inode的量很大，从中找一个空闲的inode会很慢，这时候可以找一个连续的存储空间，对inode做一个对位标识索引，第0位对应编号为0的inode编号，第1位对应编号为1的inode编号，以此类推。有N个二进制位，如果这个位为1表示这个对应的inode已被使用，这个位为0表示其对应的Inode空闲。当要创建inode时，就不用再全盘扫描了，只需要扫描这个二级索引（对位标识索引），如此一来，效率就大大提高了。而这个二级索引就是inode位图索引（inode bitmap）。数据区以同样的原理就有了块位图（block bitmap）
	inode bitmap：对位标识每个inode空闲与否的状态信息
	如果整盘进行管理，假设整盘有100万个块，100万个块扫描一遍也挺耗时间的。所以无论是inode位图还是block位图，都不是全文件系统管理的，而是块组管理的。

5.3.5 文件访问过程
	a) 查索引节点（Inode）
	b) 在索引节点中找到磁盘块的编号
	c) 在数据区找到对应的磁盘块

5.3.6 目录
	插入块组内部图
	文件访问时要先查inode，但是inode表中包含很多的inode，如何确定文件对应的Inode是哪个呢？这就是目录的作用。
	目录也是一个文件，存在数据区的一个块中，目录实质上就是一个路径映射。
	目录中存储着以下内容：
		a) 一级目录下所有的文件名列表
		b) 一级目录下所有文件对应的inode编号

5.3.7 文件创建
	a) 在元数据区找一个空闲的inode块存储inode信息
	b) 在数据区找一个或一些空闲的block块，并将其与inode建立映射关系
	c) 把数据填充至这些block块中
	d) 把标志位设为1（正在使用中的状态）

5.3.8 硬链接
	多个文件指向同一个inode，称之为硬链接。这些文件名称可相同也可不同，不能链接不同文件系统的文件。
	硬链接特点：
        a) 只能对文件创建，不能应用于目录；
        b) 不能跨文件系统；
        c) 创建硬链接会增加文件被链接的次数

5.3.9 软链接
	软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。
	软链接特点：
        a) 可应用于目录；
        b) 可以跨文件系统；
        c) 不会增加被链接文件的链接次数；
        d) 其大小为指定的路径所包含的字符个数
    创建软链接：
    	ln [-s -v] SRC DEST

5.4 btrfs文件系统
5.4.1 btrfs文件系统介绍
	btrfs文件系统自centos7后开始支持。
	Btrfs（B-tree,Butter FS,Better FS），遵循GPL规范，由Oracle自2007年开始研发。
	Btrfs文件系统的核心特性：
		a) 支持写时复制机制（CoW）：复制、更新及替换指针，而非传统的“就地”更新
			假设要修改一个文件，写时复制机制就是先把这个文件复制一个副本出来，然后对这个副本进行修改，修改完以后将文件名的指针由指向原文件改为指向这个副本。
			如此一来，原文件还在内存中，若副本修改有误还可以通过恢复指针指向的方法还原成原文件
		b) 多物理卷支持
			btrfs可由多个底层物理卷组成，支持RAID，以联机“添加”、“移除”、“修改”
		c) 支持数据及元数据校验码机制（CheckSum）
			存储文件时，会将元数据的校验码和数据的校验码通过文件某些属性扩展给保存下来。因此文件读取时可以很方便、快速的去检测文件是否受损，一旦受损还会自动尝试进行修复
		d) 支持子卷（sub_volume，相当于ext系列文件系统的lvm/lvm2）
			可以将多个底层的物理设备（硬盘）组织成btrfs文件系统，这个btrfs文件系统可以直接挂载使用，也可以在内部创建子卷（就像在VG中创建LV一样）
		e) 支持快照（快照是子卷的一个非完全副本，基于CoW机制实现的另外一个存储空间刚开始为0的一个卷）
			btrfs文件系统直接支持快照，而ext3/ext4要想支持快照必须使用lvm2来实现
			可以针对单个文件做快照，也可以针对卷做快照
			还支持对做好的快照再做一次快照，做累积性快照。类似于实现增量备份
		f) 支持透明压缩机制
			当要存储一个很大的文件，但又想节约空间的时候，可以把任何数据流发往btrfs文件系统时，自动能够通过占据CPU时钟周期完成数据压缩以后存放，对用户来说这个过程是透明的。在读取这些压缩后存放的文件时，能够自动解压缩。
			有一个缺陷：压缩和解压缩会占据更多的时钟周期
	Btrfs主要设计目标是取代Linux早期一直使用的ext3、ext4，但事实上在ext3、ext4的缺陷暴露之后，在centos6上就提供了另外一种可用的文件系统（xfs）。
5.4.2 btrfs文件系统的实现
	mkfs.btrfs：创建btrfs文件系统
		-L|--label <name>：指定卷标
		-m|--metadata <profile>：指明元数据如何存放
			Valid values are raid0，raid1，raid5，raid6，raid10，single or dup
		-d|--data <type>：指明数据如何存放
			Valid values are raid0，raid1，raid5，raid6，raid10 or single
		-O|--features <feature1>[,<feature2>...]：在格式化时直接开启指定的功能
			A list of filesystem features turned on at mkfs time.Not all features are supported by old kernels.
			To see all features run
				mkfs.btrfs -O list-all

	常用的btrfs文件系统的命令：
	btrfs：管理btrfs文件系统
		btrfs filesystem show [--mounted|--all-devices|<uuid>]：显示btrfs文件系统信息
		btrfs filesystem sync <path>：强制把指定btrfs文件系统缓存在内存中的数据同步到硬盘中
		btrfs filesystem df <path> [<path>...]：查看已挂载的btrfs文件系统空间使用率
		btrfs filesystem defragment [options] <file>|<dir> [<file>|<dir>...]：消除磁盘碎片
		btrfs filesystem resize [devid:][+/-]<size>[gkm]|[devid:]max <path>：修改文件系统大小
		btrfs filesystem label [<device>|<mount_point>] [<newlabel>]：显示或更新btrfs文件系统卷标
		
	挂载btrfs文件系统：
		mount -t btrfs /dev/sdb MOUNT_POINT
			/dev/sdb这个位置只要是btrfs文件系统的底层物理卷之一，随便写哪个物理卷名均可
	透明压缩机制：
		mount -o compress={lzo|zlib} DEVICE MOUNT_POINT

	btrfs-convert：实现无损地将ext系列的文件系统动态转换成btrfs文件系统或将btrfs文件系统降级为ext系列的文件系统
	btrfsck：实现文件系统的检测


第六章 加密与解密
6.1 什么是加密和解密？
	加密技术是最常用的安全保密手段，利用技术手段把重要的数据变为乱码（加密）传送，到达目的地后再用相同或不同的手段还原（解密）。
6.2 加密技术二元素：算法和密钥
	算法是将普通的信息或者可以理解的信息与一串数字（密钥）结合，产生不可理解的官方的步骤；
	密钥是用来对数据进行编码和解密的一种算法。

	在安全保密中，可通过适当的密钥加密技术和管理机制来保证网络的信息通信安全，使得未授权的用户即使获得了已加密的信息，但因不知解密方法，仍然无法了解信息内容。
6.3 为什么要加密？
	随着人类社会逐渐步入信息时代，信息安全也越来越受到关注。对计算机而言，信息表现为各种各样的数据，是否采用了适当的方法对数据进行加密，已成为保障数据安全的首要方法。为了保密，一般在网络上传输的重要数据文件都可以对其进行加密，但数据加密也不一定是为了在网络间传输文件，而是为了保证机密文件即使失窃后也不泄漏其中的重要信息。
	随着网络技术的发展，大量的数据需要在网络上传输。在网络上传输的数据存在着不安全的因素而变得危险，而且这种危险是TCP/IP协议所固有的。一些基于TCP/IP的服务（ftp,http,smtp,telnet）都是明文传输的，其机密性无法得到保证。
	数据加密在网络上的作用就是防止重要信息在网络上被拦截和窃取，一个简单的例子就是计算机口令的传输。
	计算机口令极为重要，许多安全防护体系是基于口令的，口令的泄露关系到安全体系的全面崩溃。通过网络进行登录时，所键入的口令以明文的形式被传输到服务器，而网络上的窃听是一件极为容易的事情，所以很有可能被黑客嗅探并窃得用户的口令，如果用户是root用户或administrator用户，那后果是极为严重的。
	解决这个问题的方法就是加密，加密后的口令即使被黑客获得也是不可读的，除非加密密钥或加密方式十分脆弱，很容易被黑客破解。whatever，加密的作用是使黑客不会轻易获得口令。
6.4 加密类型
	加密类型有以下几种：
		对称加密：加密解密使用同一个密钥
			DES：Data Encrption Standard，56bit
			3DES：使用3条56位的密钥对数据进行三次加密
			AES：Advanced Encrption Standard，128bit（默认）
				AES192：192bit
				AES256：256bit
				AES512：512bit
			Blowfish：一个64位分组及可变密钥长度的对称密钥分组密码算法，可用来加密64bit长度的字符串
		公钥加密：也叫非对称加密。有一对密钥，公钥（P）和私钥（S）。
			公钥隐含于私钥中，可以提取出来并公布出去。
			公钥加密算法很少用来加密数据，因为加密速度太慢，比对称加密慢1000倍。常用于做身份验证
			公钥加密能保证机密性和身份验证：
				机密性：发送方用对方的公钥加密
				身份验证：发送方用自己的私钥加密（数字签名）
			公钥加密能实现加密和签名功能：
				RSA：即能实现加密，也能实现签名
				DSA：只能实现签名
				ELGamal：商业加密算法
		单向加密：也叫散列加密，提取数据特征码，能加密不能解密，常用于做数据完整性校验
			MD4，MD5，SHA1，SHA192，SHA256，SHA384，SHA512，CRC-32（循环冗余检验码）
			单向加密的特性：
				a) 雪崩效应（输入的微小改变，将会引起结果的巨大改变）
				b) 定长输出（无论原始数据是多大，结果的长度是相同的）
					MD5：Message Digest，128位定长输出
					SHA1：Secure Hash Algorithm，160位定长输出
				c) 不可逆（无法根据特征码还原成原始数据）
6.5 密钥交换
	协商生成密码的过程叫做密钥交换（Internet Key Exchange，IKE）
	使用的是DH协议（Diffie-Hellman）：
		A --> B
			p,g（大素数，生成数），在网络中传输的，公开的
		A：自己取一个随机数x
		B：自己取一个随机数y
		A：g^x%p --> B
		B：g^y%p --> A
		A：(g^y%p)^x=g^yx%p
		B：(g^x%p)^y=g^xy%p
	这最后得出的g^xy%p就是最终的密钥
6.6 PKI
	PKI：Public Key Infrastructure
	PKI的核心就是CA及其信任关系
6.6.1 CA
	CA（Certificate Authority）是数字证书认证中心的简称，是指发放、管理、废除数据证书的机构。
	CA的作用是检查证书持有者身份的合法性，并签发证书（在证书上签字），以防证书被伪造或篡改，以及对证书和密钥进行管理
6.6.2 数字证书
	数字证书实际上是存在于计算机上的一个记录，是由CA签发的一个声明，证明证书主体（"证书申请者"拥有了证书后即成为"证书主体"）与证书中所包含的公钥的惟一对应关系
	数字证书包含的内容：
		申请者的名称及相关信息
        申请者的地址信息
        申请者的公钥
        签发证书的CA的名称
        签发证书的CA的数字签名(用发证机关的私钥加密的特征码)
        证书有效期
    x509证书的内容：
        公钥及其有效期限
        证书的合法拥有者
        证书该如何被使用
        CA的信息
        CA签名的校验码
    CRL：证书吊销列表。CRL中记录的是已经发出去的、没有过期的但已经被撤销的证书
6.6.3 PKI的实现架构
	TLS/SSL：使用x509证书
	OpenGPG
	插入架构图
	SSL：Secure Socket Layer，安全的套接字层。只是一个库，可以将http、smtp、ftp等应用层协议封装成https、smtps、ftps等
	TLS：Transport Layer Security，TLSv1版本相当于SSLv3

	SSL会话过程：
        a) TCP三次握手
        b) 客户端向服务器发起会话请求
        c) 服务器与客户端协商建立SSL会话（协商加密协议：SSLv2、SSLv3、TLS；协商加密算法）
        d) 服务器将自己的证书发给客户端
        e) 客户端验证证书是否是自己所信任的根证书颁发机构所发，证书是否完整
        f) 客户端随机生成一个会话密钥（对称密钥），用服务器的公钥进行加密，传递给服务器端
        g) 服务器端用客户端生成的对称密钥对数据进行加密，传输给客户端
6.6.4 证书申请及签署步骤
	a) 生成申请请求
	b) RA核验
	c) CA签署
	d) 获取证书
6.6.5 吊销证书
	a) 客户端获取要吊销的证书的serial
		openssl x509 -in /path/from/cert_file -noout -serial -subject
	b) CA端先客户端提交的serial与subject信息，对比检验是否与index.txt文件中的信息一致
		吊销证书：
			openssl ca -revoke /etc/pki/CA/newcerts/SERIAL.pem
	c) 生成吊销证书的编号（第一次吊销一个证书时）
		echo 01 > /etc/pki/CA/crlnumber
	d) 更新证书吊销列表
		openssl ca -gencrl -out thisca.crl
		
6.7 openssl
	对称加密的实现工具有openssl和gpg两种
	openssl：OpenSSL是ssl的开源实现，是一个软件，由三部分组成：
		libcrypto：加密库
		libssl：TLS/SSL协议的实现。基于会话的实现了身份认证、数据机密性和会话完整性的TLS/SSL库
		openssl：多用途命令行工具。能够实现单向加密、对称加密、非对称加密、生成一对密钥、私有证书颁发机构等功能
	openssl：
		语法：openssl command [ command_opts ] [ command_args ]
		command：
			enc：加密/解密
				-e：加密
				-d：解密
			dgst：提取文件特征码
			passwd -1：生成密码串
			rand -base64：生成伪随机数
			req：证书注册提交管理
				-new：生成新证书签署请求
				-x509：专用于CA生成自签证书
				-key：生成请求时用到的私钥文件
				-days n：证书的有效期限
				-out /path/to/somecertfile：证书的保存路径
			x509：管理证书
				-in /path/from/cert_file -noout -text|-subject|-serial    #查看证书中的信息
			crl：管理吊销证书列表
				-in /path/from/crl_file.crl -noout -text    #查看crl文件
			ca：管理CA
	openssl实现私有CA：
		CA的配置文件：/etc/pki/tls/openssl.cnf
		a) CA生成一对密钥
			cd /etc/pki/CA 
			(umask 077;openssl genrsa -out private/cakey.pem 2048)    #生成密钥，括号必须要
			openssl rsa -in private/cakey.pem -pubout    提取公钥
		b) CA生成自签署证书
			openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 365    #生成自签署证书
			openssl x509 -text -in cacert.pem    #读出cacert.pem证书的内容
			mkdir certs newcerts crl
			touch index.txt && echo 01 > serial
		c) 客户端（例如httpd服务器）生成密钥
			cd /etc/httpd && mkdir ssl && cd ssl
			(umask 077;openssl genrsa -out httpd.key 2048)
		d) 客户端生成证书签署请求
			openssl req -new -key httpd.key -days 365 -out httpd.csr
		e) 客户端把证书签署请求文件发送给CA
			scp httpd.csr root@CA端IP:/root
		f) CA签署客户端提交上来的证书
			openssl ca -in /root/httpd.csr -out httpd.crt -days 365
		g) CA把签署好的证书httpd.crt发给客户端
			scp httpd.crt root@客户端IP:/etc/httpd/ssl/

第七章 selinux
7.1 DAC与MAC
	DAC：Linux自己的安全机制叫做DAC（Discretionary Access Control，自主访问控制）
	MAC：SELinux实现的功能叫做MAC（Mandatory Access Control，强制访问控制机制）
7.2 selinux的工作级别与机制
	SELinux：Secure Enhanced Linux，工作于Linux内核中。
	SELinux有两种工作级别：
		strict：严格级别，每个进程都受到selinux的控制
		targeted：仅有限个进程受到selinux的控制
			只监控容易被入侵的进程
	SELinux工作机制：
		SELinux采用类似沙箱（sandbox）的方式来运行进程：
			subject operation object
			subject：进程
			object：可以是进程，可以是文件
				适用于文件的操作：open，read，write，close，chown，chmod
		SELinux为每个文件提供了安全标签，也为进程提供了安全标签：
			user:role:type
			user：SELinux的user
			role：角色
			type：类型
		SELinux规则库：
			规则：定义了哪种域能访问哪种或哪些种类型内的文件
			遵循“法无授权即禁止”的规则，也就是说没有明确授权的所有操作均禁止
7.3 selinux的配置
	SELinux是否启用：在/etc/selinux/config文件中定义
	SELinux的状态：
		enforcing：强制，每个受限的进程都必然受限
		permissive：启用，每个受限的进程违规操作时不会被禁止，但会被记录于审计日志
		disabled：禁用
		相关命令：
			getenforce：获取selinux当前状态
			setenforce 0｜1
				0：设置为permissive
				1：设置为enforcing
			此设定仅当前有效，重启系统后无效
			配置文件：/etc/sysconfig/selinux，/etc/selinux/config
				SELINUX=｛disabled｜enforcing｜permissive｝
	给文件重新打标签：
		chcon：change context，改变上下文
		chcon [option]... CONTEXT FILE...
		chcon [option]... [-u USER] [-r ROLE] [-t TYPE] FILE...
		chcon [option]...  --reference=RFILE FILE...
		-R：递归打标签
	还原文件的默认标签： 
		restorecon [-R] /path/to/somewhere（可以是文件，也可以是目录）
	设定某些布尔型特性：
		getsebool
			getsebool [-a] [boolean]
			例：
				getsebool -a
				getsebool ftp_home_dir
		setsebool
			setsebool [ -PV] boolean value | bool1=val1 bool2=val2 ...
			-P：把设置添加进规则库，使之永久生效，若不使用此选项则只当前有效，重启系统会失效

第八章 进程间交互
8.1 OSI参考模型
8.1.1 OSI参考模型简介
	OSI（Open System Interconnect），即开放式系统互联。一般都叫OSI参考模型。
	OSI参考模型是ISO（国际标准化组织）组织在1985年研究的网络互联模型。该体系统结构标准定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），即ISO开放系统互连参考模型。在这一框架下进一步详细规定了每一层的功能，以实现开放系统环境中的互连性、互操作性和应用的可移植性。

	1-7层数据单位分别为：比特--帧--报文--TPDU--SPDU--PPDU--APDU
		帧中保存的最主要的信息是网卡的硬件MAC地址，MAC地址负责局域网通信
		报文中保存的主要有IP地址，IP地址负责互联网通信
		传输层的数据单位是段，TPDU是传输协议数据单元
		SPDU是会话协议数据单元
		PPDU是表示层协议数据单元
		APDU是应用协议数据单元

	分层的目的：
		a) 方便管理数据
		b) 方便定位故障
		c) 某一层出现问题不会影响其它层
	5-7层是用来对用户提供服务，1-4层对实际的数据传递提供服务。数据的发送是从上层（7）传到下层（1），然后通过物理层传递到对方，接收的时候从下层传递到上层
8.1.2 OSI参考模型的作用
	物理层：设备之间的比特流的传输、物理接口、电气特性等（8根网线，1326四根线负责传输数据）
	数据链路层：成帧、用MAC地址访问媒介、错误检测与修正，提供物理地址（mac地址）寻址功能
	网络层：提供逻辑地址（IP地址）寻址功能
	传输层：可靠与不可靠的传输（TCP/UDP）、传输前的错误检测以及流控
	会话层：对应用会话的管理、同步
	表示层：数据的表现形式、特定功能的实现，如加密等
	应用层：提供用户接口，方便编程

8.2 TCP/IP四层模型
8.2.1 TCP/IP四层模型简介
	TCP/IP参考模型是计算机网络的祖父ARPANET和其后继的因特网使用的参考模型。ARPANET是由美国国防部DoD（U.S.Department of Defense）赞助的研究网络。逐渐地它通过租用的电话线连结了数百所大学和政府部门。当无线网络和卫星出现以后，现有的协议在和它们相连的时候出现了问题，所以需要一种新的参考体系结构。这个体系结构在它的两个主要协议出现以后，被称为TCP/IP参考模型（TCP/IP reference model）。
	TCP/IP是一组用于实现网络互连的通信协议。Internet网络体系结构以TCP/IP为核心。基于TCP/IP的参考模型将协议分成四个层次，分别是：网络访问层、网际互联层、传输层（主机到主机）和应用层。
	网络接入层（即主机-网络层）：网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。
		事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。
	网际互连层：网际互连层对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。
		它所包含的协议设计数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。
		该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。
		IP协议是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务。
	传输层：传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。
		该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP）
		TCP协议提供的是一种可靠的、通过“三次握手”来连接的数据传输服务
		UDP协议提供的则是不保证可靠的（并不是不可靠）、无连接的数据传输服务
	应用层：应用层对应于OSI参考模型的高层，为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP等
	此段落摘自百度百科
8.2.2 模型比较
	OSI参考模型与TCP/IP四层模型的共同点：
		a) OSI参考模型和TCP/IP参考模型都采用了层次结构的概念
		b) 都能够提供面向连接和无连接两种通信服务机制
	OSI参考模型与TCP/IP四层模型的不同点：
		a) OSI采用的七层模型，而TCP/IP是四层结构
		b) TCP/IP参考模型的网络接口层实际上并没有真正的定义，只是一些概念性的描述。而OSI参考模型不仅分了两层，而且每一层的功能都很详尽，甚至在数据链路层又分出一个介质访问子层，专门解决局域网的共享介质问题
		c) OSI模型是在协议开发前设计的，具有通用性。TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络
		d) OSI参考模型与TCP/IP参考模型的传输层功能基本相似，都是负责为用户提供真正的端对端的通信服务，也对高层屏蔽了底层网络的实现细节。所不同的是TCP/IP四层模型的传输层是建立在网络互联层基础之上的，而网络互联层只提供无连接的网络服务，所以面向连接的功能完全在TCP协议中实现，当然TCP/IP的传输层还提供无连接的服务，如UDP；相反OSI参考模型的传输层是建立在网络层基础之上的，网络层即提供面向连接的服务，又提供无连接的服务，但传输层只提供面向连接的服务
		e) OSI参考模型的抽象能力高，适合于描述各种网络；而TCP/IP是先有了协议，才制定TCP/IP模型的
		f) OSI参考模型的概念划分清晰，但过于复杂；而TCP/IP四层模型在服务、接口和协议的区别上不清楚，功能描述和实现细节混在一起
		g) TCP/IP四层模型的网络接口层并不是真正的一层；OSI参考模型的缺点是层次过多，划分意义不大但增加了复杂性

8.3 进程间通信
	插入应用程序模型图片
	如上图所示，上三层所对应的属于用户进程，而下四层所对应的是属于内核的功能，是特权进程，在此之前我们曾经说过，特权进程只有内核才能执行，普通用户是无法执行的。下四层的主要作用就是封装、解封装以及在网络中传输数据到达目的地。
	在这里我们主要说下传输层，传输层通过SOCKET提供进程地址。在此之前我们先来说说端口号，因为SOCKET主要形式是IP+PORT。
	Port Number：
		tcp：传输控制协议，面向连接的协议。通信前需要建立虚拟链路，结束后拆除链路
			0-65535
		udp：User Datagram Protocol，无连接的协议
			0-65535
	IANA：Intelnet Address Name Allocation，互联网地址名称分配
		0-1023：众所周知，永久的分配给固定的应用使用，属于特权端口，只有root用户才能使用，如22/tcp（ssh），80/tcp（http），443/tcp（https）
		1024-41951：亦为注册端口，但要求并不是特别严格，分配给程序注册为某应用使用，普通用户可以使用，11211/tcp，11211/udp（memcached），3306/tcp（mysql）
		41952-65535：客户端程序随机使用的端口。动态端口，或私有端口，其范围的定义在/proc/sys/net/ipv4/ip_local_port_range
	Socket：是IPC（inter-process communication，内部过程通信）的一种实现，允许位于不同主机或同一主机上不同进程之间进行通信，实现数据交换。
	Socket分类（根据其使用的端口进行分类）：
        SOCK_STREAM：tcp套接字
        SOCK_DGRAM：udp套接字
        SOCK_RAW：裸套接字（不借助TCP/UDP端口号而直接通过IP地址封装报文以后实现通信）
	Socket Domain（根据其所使用的地址进行分类）：
	    AF_INET：Address Family，IPv4套接字家族
	    AF_INET6：IPv6套接字家族
	    AF_UNIX：同一主机上不同进程间进行通信
	    每类套接字都至少提供了两种socket机制：流（tcp）和数据报（udp）
	        流：可靠地传递、面向连接、无报文边界
	        数据报：不可靠地传递、有报文边界、无连接
	套接字相关的系统调用：
        socket()：创建一个套接字
        bind()：绑定套接字
        listen()：监听套接字
        accept()：接收请求
        connect()：请求连接建立
        write()：发送数据
        read()：接收数据


第九章 网络文件共享服务之NFS
9.1 nfs介绍
9.1.1 nfs特点
	NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。
	在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样
	nfs适用于Linux与Unix之间实现文件共享，不能实现Linux与Windows间的文件共享功能
	nfs是运行在应用层的协议，其监听于2049/tcp和2049/udp套接字上
	nfs服务只能基于IP进行认证，这也是它的缺点之一
9.1.2 使用nfs的好处
	a) 节省本地存储空间，将常用的数据存放在一台NFS服务器上且可以通过网络访问，那么本地终端将可以减少自身存储空间的使用
	b) 用户不需要在网络中的每个机器上都建有Home目录，Home目录可以放在NFS服务器上且可以在网络上被访问使用
	c) 一些存储设备如软驱、CDROM和Zip（一种高储存密度的磁盘驱动器与磁盘）等都可以在网络上被别的机器使用。这可以减少整个网络上可移动介质设备的数量
9.1.3 nfs的体系组成
	nfs体系至少有两个主要部分：
		一台NFS服务器
		若干台客户机
	nfs体系的架构图如下：
	插入nfs体系图片

	客户机通过TCP/IP网络远程访问存放在NFS服务器上的数据
	在NFS服务器正式启用前，需要根据实际环境和需求，配置一些NFS参数
9.1.4 nfs的应用场景
	nfs有很多实际应用场景，以下是一些常用的场景：
	a) 多个机器共享一台CDROM或其他设备。这对于在多台机器中安装软件来说更加便宜与方便
	b) 在大型网络中，配置一台中心NFS服务器用来放置所有用户的home目录可能会带来便利。这些目录能被输出到网络以便用户不管在哪台工作站上登录，总能得到相同的home目录
	c) 不同客户端可在NFS上观看影视文件，节省本地空间
	d) 在客户端完成的工作数据，可以备份保存到NFS服务器上用户自己的路径下

9.2 nfs工作机制
	nfs是基于rpc来实现网络文件系统共享的。所以我们先来说说rpc
9.2.1 RPC
	RPC（Remote Procedure Call Protocol），远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。
	RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。
	RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。

	插入rpc工作机制图

	rpc工作机制如上图所示，下面来描述一下它：
	a) 客户端程序发起一个RPC系统调用基于TCP协议发送给另一台主机（服务端）
	b) 服务端监听在某个套接字上，当收到客户端的系统调用请求以后，将收到的请求和其所传递的参数通过本地的系统调用执行一遍，并将结果返回给本地的服务进程
	c) 服务端的服务进程收到返回的执行结果后将其封装成响应报文，再通过rpc协议返回给客户端
	d) 客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行

	CentOS6中RPC服务的进程名是portmapper，可以通过rpcinfo -p查看当前系统使用的RPC服务名
9.2.2 NIS
	NIS：Network Information System，网络信息系统，是对主机帐号等系统提供集中管理的网络服务。
	用户登录任何一台NIS客户机都会从NIS服务器进行登录认证，可实现用户帐号的集中管理
	NIS协议是明文的，所以NIS一般不建议在公网中使用而通常在局域网中使用。
	此章主要是讲NFS，所以NIS的配置这里就不详说了，有兴趣的朋友可以去网上搜索
9.2.3 nfs工作机制	
	NFS服务器端运行着四个进程：nfsd，mountd，idmapd，portmapper
		idmapd：实现用户帐号的集中映射，把所有的帐号都映射为NFSNOBODY，但是在访问时却能以本地用户的身份去访问
		mountd：用于验证客户端是否在允许访问此NFS文件系统的客户端列表中，在则允许访问（发放一个令牌，持令牌去找nfsd），否则拒绝访问
			mountd的服务端口是随机的，由rpc服务（portmapper）提供随机端口号
		nfsd：nfs的守护进程，监听在2049/tcp和2049/udp端口上
			不负责文件存储（由NFS服务器本地内核负责调度存储），用于理解客户端发起的rpc请求，并将其转交给本地内核，而后存储在指定的文件系统上
		portmapper：NFS服务器的rpc服务，其监听于111/TCP和111/UDP套接字上，用于管理远程过程调用（RPC）
	下面通过一个例子来说明NFS的简单工作流程：
		需求：查看file文件的信息，此file存储在远程NFS服务端主机上（挂载在本地目录/shared/nfs中）
		插入NFS工作机制图
		（1）客户端发起查看file信息的指令（ls file）给内核，内核通过NFS模块得知此文件并不是本地文件系统中的文件，而是在远程NFS主机上的一个文件
		（2）客户端主机的内核通过RPC协议把查看file信息的指令（系统调用）封装成rpc请求通过TCP的111端口发送给NFS服务端主机的portmapper
		（3）NFS服务端主机的portmapper（RPC服务进程）告诉客户端说NFS服务端的mountd服务在某某端口上，你去找它验证
			因为mountd在提供服务时必须要向portmapper注册一个端口号，所以portmapper是知道其工作于哪个端口的
		（4）客户端得知服务端的mountd进程端口号后，通过已知的服务端mountd端口号请求验证
		（5）mountd收到验证请求后验证发起请求的客户端是否在允许访问此NFS文件系统的客户端列表中，在则允许访问（发放一个令牌，持令牌去找nfsd），否则拒绝访问
		（6）验证通过后客户端持mountd发放的令牌去找服务端的nfsd进程，请求查看某文件
		（7）服务端的nfsd进程发起本地系统调用，向内核请求查看客户端要查看的文件的信息
		（8）服务端的内核执行nfsd请求的系统调用，并将结果返回给nfsd服务
		（9）nfsd进程收到内核返回的结果后将其封装成rpc请求报文并通过tcp/ip协议返回给客户端

9.3 nfs的配置
	主配置文件：/etc/exports，文件中的项的格式相当简单，要共享一个文件系统，只要在文件中添加如下条目即可
		directory（or file system） client1（option1，option2） client2（option1，option2）
	nfs主配置文件中的常用选项（option）：
		secure：这个选项是缺省项，它使用了1024以下的TCP/IP端口实现NFS的连接。指定insecure可以禁用这个选项
		rw：允许NFS客户机进行读/写访问。缺省选项是只读的
		async：此选项可以改进性能，但如果没有完全关闭NFS守护进程就重启了NFS服务器，这也可能会造成数据丢失。
		no_wdelay：此选项关闭写延时。如果设置了async，那么NFS就会忽略此选项
		nohide：若将一个目录挂载到另一个目录之上，则原来的目录通常就被隐藏起来或看起来像空的一样。要禁用这种行为，需启用hide选项
		no_subtree_check：此选项关闭子树检查，子树检查会执行一些不想忽略的安全性检查。缺省选项是启用子树检查
		no_auth_nlm：此选项可作为insecure_locks指定，它告诉NFS守护进程不要对加锁请求进行认证。若关心安全性问题，就要避免使用此选项。缺省选项是auth_nlm或secure_locks
		mp（mountpoint=path）：通过显式的声明此选项，NFS要求挂载所导出的目录
		fsid=num：此选项通常在NFS故障恢复时使用。若希望实现NFS的故障恢复，请参考NFS文档
	用户映射：
		通过NFS中的用户映射，可以将伪或实际用户和组的标识赋给一个正在对NFS卷进行操作的用户。这个NFS用户具有映射所允许的用户和组的许可权限。
		对NFS卷使用一个通用的用户/组可以提供一定的安全性和灵活性，而不会带来很多管理负荷。
		在使用NFS挂载的文件系统上的文件时，用户的访问通常都会受到限制，这就是说用户都是以匿名用户的身份来对文件进行访问的，这些用户缺省情况下对这些文件只有只读权限。
		这种行为对于root用户来说尤其重要。然而，实际上的确存在这种情况：希望用户以root用户或所定义的其他用户的身份访问远程文件系统上的文件。
		NFS允许指定访问远程文件的用户--通过用户标识号（UID）和组标识号（GID），可以禁用正常的squash行为。
		用户映射的选项：
			root_squash：此选项不允许root用户访问挂载上来的NFS卷
			no_root_squash：此选项允许root用户访问挂载上来的NFS卷
			all_squash：此选项对于公共访问的NFS卷来说非常有用，它会限制所有的UID和GID，只使用匿名用户。缺省设置是no_all_squash
			anonuid和anongid：这两个选项将匿名UID和GID修改成特定用户和组帐号
	查看NFS服务器端共享的文件系统：
		showmount -e NFSSERVER_IP
	挂载NFS文件系统：
		mount -t nfs SERVER:/path/to/sharedfs /path/to/mount_point
	开机自动挂载nfs：编辑/etc/fstab文件，添加如下格式的内容
		SERVER:/PATH/TO/EXPORTED_FS	/mnt_point	nfs	defaults,_netdev	0 0
	客户端挂载时可以使用的特殊选项：
		Client
			Mounting remote directories
			Before mounting remote directories 2 daemons should be started first：
				rpcbind
				rpc.statd
		rsize：其值是从服务器读取的字节数（缓冲）。默认为1024。若使用比较高的值，如8192，可以提高传输速度
		wsize：其值是写入到服务器的字节数（缓冲）。默认为1024。若使用比较高的值，如8192，可以提高传输速度

		The timeo value is the amount of time, in tenths of a second, to wait before resending a transmission after an RPC timout. 
		After the first timeout, the timeout value is doubled for each retry for a maximum of 60 seconds or until a major timeout occurs.
		If connecting to a slow server or over a busy network, better performance can be achiveved by increasing this timeout value.
		The intr option allows signals to interrupt the file operation if a major timeout occurs for a hard-mounted share.
	exportfs：维护exports文件导出的文件系统表的专用工具
		export -ar：重新导出所有的文件系统
		export -au：关闭导出的所有文件系统
		export -u FS：关闭指定的导出的文件系统

第十章 网络文件共享服务之ftp
10.1 ftp介绍
	网络文件共享服务主流的主要有三种，分别是ftp、nfs、samba。在上一章中我们已经了解了nfs，本章我们将来说说ftp。

	FTP是File Transfer Protocol（文件传输协议）的简称，用于internet上的控制文件的双向传输。

	FTP也是一个应用程序，基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。

	在FTP的使用当中，用户经常遇到两种概念：下载和上传
		下载（Download）文件就是从远程主机拷贝文件至自己的计算机上
		上传（Upload）文件就是将文件从自己的计算机上拷贝至远程主机上。

10.2 ftp架构
	FTP工作于应用层，监听于tcp的21号端口，是一种C/S架构的应用程序。其有多种客户端和服务端的应用程序，下面来简单介绍一下
	Client：
		ftp
		lftp,lftpget
		wget,curl
		filezilla
		gftp（Linux GUI）
		商业软件：flashfxp，cuteftp
	Server：
		wu-ftpd
		proftpd：提供web接口的一种ftp服务端程序
		pureftp
		vsftpd：Very Secure
		ServU：windows平台的一种强大ftp服务端程序

10.3 ftp数据连接模式
	ftp有2种数据连接模式：命令连接和数据连接
	命令连接：是指文件管理类命令，始终在线的持久性连接，直到用户退出登录为止
	数据连接：是指数据传输，按需创建及关闭的连接

	其中数据连接需要关注的有2点，一是数据传输格式，二是数据传输模式
	数据传输格式有以下两种：
	a) 文件传输
	b) 二进制传输

	数据传输模式也有2种：
	a) 主动模式：由服务器端创建数据连接
	b) 被动模式：由客户端创建数据连接

	下面来介绍下两种数据传输模式的建立过程：
	主动模式：
		命令连接：
			Client（1025）--> Server（21）		客户端以一个随机端口（大于1023）来连服务器端的21号端口
		数据连接：
			Server（20/tcp） --> Client（1025+1） 	服务器端以自己的20号端口去连客户端创建命令连接时使用的随机端口+1的端口号
			此处有个弊端，因为客户端的端口是随机的，客户端如果开了防火墙，则服务器端去连客户端创建数据连接时可能会被拒绝
	被动模式：
		命令连接：
			Client（1110） --> Server（21）		客户端以一个随机端口来连成服务器端的21号端口
		数据连接：
			Client（1110+1） --> Server（随机端口）		客户端以创建命令连接的端口+1的端口号去连服务器端通过命令连接告知自己的一个随机端口号来创建数据连接

10.4 ftp响应码
	1xx：纯信息的状态码
	2xx：成功类的状态码
	3xx：提示需进一步提供补充类信息的状态码
	4xx：客户端错误
	5xx：服务端错误

10.5 用户认证
	ftp的用户主要有三种：
	a) 虚拟用户：仅用于访问某特定服务中的资源
	b) 系统用户：可以登录系统的真实用户
	c) 匿名用户

	ftp的用户认证主要通过nsswitch和pam来实现，关于nsswitch和pam，请看此处（插入超链接）

10.6 vsftpd
	此处我们要说的ftp应用程序是vsftpd，这也是在公司中用得最多的一款ftp软件。

	本章主要说一下vsftpd的配置，关于安装就不啰嗦了，详见官网（插入超链接）

	vsftpd用户认证配置文件是/etc/pam.d/vsftpd

	服务脚本为/etc/rc.d/init.d/vsftpd

	配置文件目录为/etc/vsftpd/，其中主配置文件为/etc/vsftpd/vsftpd.conf

	匿名用户（映射为ftp用户）的共享资源位置是/var/ftp

	系统用户通过ftp访问的资源位置为用户的家目录

	虚拟用户通过ftp访问的资源位置为给虚拟用户指定的映射成为的系统用户的家目录

10.7 vsftpd的常用配置
	匿名用户的配置：
		anonymous_enable=YES	启用匿名用户登录
		anon_upload_enable=YES	允许匿名用户上传
		anon_mkdir_write_enable=YES	允许匿名用户创建目录，但是不能删除
		anon_other_write_enable=YES	允许匿名用户创建和删除目录

	系统用户的配置：
		local_enable=YES		启用本地用户登录
		write_enable=YES		允许本地用户有写权限
		local_umask=022		通过ftp上传文件的默认遮罩码
		chroot_local_user=YES	禁锢所有的ftp本地用户于其家目录中
		禁锢文件（/etc/vsftpd/chroot_list）中指定的ftp本地用户于其家目录中：
			chroot_list_enable=YES
			chroot_list_file=/etc/vsftpd/chroot_list

	虚拟用户的配置：
		所有的虚拟用户会被统一映射为一个指定的系统帐号，访问的共享位置即为此系统帐号的家目录
		各虚拟用户可被赋予不同的访问权限，通过匿名用户的权限控制参数进行指定

		虚拟用户帐号的存储方式：
		a) 文件：编辑文件，此文件需要被编码为hash格式。
			奇数行为用户名
			偶数行为密码
		b) 关系型数据库的表中：
			通过即时查询数据库完成用户认证
			mysql库：pam要依赖于pam_mysql软件，可以通过epel源yum安装

	日志配置：
		xferlog_enable=YES	是否启用传输日志，记录ftp传输过程
		xferlog_std_format=YES		传输日志是否使用标准格式
		xferlog_file=/var/log/xferlog	指定传输日志存储的位置

	改变上传文件的属主：自动将客户端上传到服务器的某文件的属主改为指定的用户
		chown_uploads=YES	是否启用改变上传文件属主的功能
		chown_username=whoever	指定要将上传的文件的属主改为哪个用户，此用户必须在系统中存在

	vsftpd使用pam完成用户认证，其用到的pam配置文件：
		pam_service_name=vsftpd	指定vsftpd使用/etc/pam.d下的哪个pam配置文件进行用户认证

	是否启用控制用户登录的列表文件：默认为/etc/vsftpd/user_list文件
		userlist_enable=YES
		userlist_deny=YES		是否拒绝userlist指定的列表文件中存在的用户登录ftp

	连接限制：
		max_clients=#		最大并发连接数
		max_per_ip=#		每个IP可同时发起的并发请求数

	传输速率：
		anon_max_rate	匿名用户的最大传输速率，单位是“字节/秒”
		local_max_rate	本地用户的最大传输速率，单位是“字节/秒”

	通用配置：
		dirmessage_enable=YES	启用某目录下的.message描述信息
			假定有一个目录为/upload，在其下创建一个文件名为.message，在文件内写入一些描述信息，则当用户切换至/upload目录下时会自动显示.message文件中的内容
		message_file	设置访问一个目录时获得的目录信息文件的文件名,默认是.message
		idle_session_timeout=600	设置默认的断开不活跃session的时间
		data_connection_timeout=120	设置数据传输超时时间
		ftpd_banner=Welcome to chenlf FTP service.	定制欢迎信息，登录ftp时自动显示

10.8 vsftpd虚拟用户配置
	vsftpd虚拟用户的配置步骤如下，这里使用mysql进行用户认证
	a) 安装所需要的程序
		yum -y install vsftpd mysql-server mysql-devel pam_mysql
		注意：pam_mysql由epel源提供
	b) 创建虚拟用户帐号
		准备数据库及相关表：首先确保mysql服务已经正常启动。而后，按需要建立存储虚拟用户的数据库即可，这里将其创建为vsftpd数据库
			mysql> CREATE DATABASE vsftpd;
			mysql> GRANT SELECT ON vsftpd.* TO 'vsftpd'@'localhost' IDENTIFIED BY 'Your password';
			mysql> GRANT SELECT ON vsftpd.* TO 'vsftpd'@'127.0.0.1' IDENTIFIED BY 'Your password';
			mysql> FLUSH PRIVILEGES;

			mysql> use vsftpd;
			mysql> CREATE TABLE users (
			id int UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
			name char(20) binary NOT NULL,
			password char(48) binary NOT NULL
			);
		添加测试的虚拟用户：根据需要添加所需要的用户，需要说明的是，这里将其密码为了安全起见应使用PASSWORD函数加密后存储
			mysql> INSERT INTO users(name,password) values('tom',password('Your password'));
			mysql> INSERT INTO users(name,password) values('jerry',password('Your password'));
	c) 配置vsftpd
		建立pam认证所需文件，编辑/etc/pam.d/vsftpd.mysql文件，添加如下两行：
			auth required /lib64/security/pam_mysql.so user=vsftpd passwd='Your password' host=mysqldb_ip db=vsftpd table=users usercolumn=name passwdcolumn=password crypt=2
			account required /lib64/security/pam_mysql.so user=vsftpd passwd='Your password' host=mysqldb_ip db=vsftpd table=users usercolumn=name passwdcolumn=password crypt=2
		注意：由于mysql的安装方式不同，pam_mysql.so基于unix sock连接mysql服务器时可能会出问题，此时，建立授权一个可远程连接的mysql并访问vsftpd数据库的用户

		修改vsftpd的配置文件/etc/vsftpd/vsftpd.conf，使其适应mysql认证
			建立虚拟用户映射的系统用户及对应的目录：
				建立虚拟用户映射的系统用户及对应的目录：
					useradd -s /sbin/nologin -d /var/ftproot vuser
					chmod go+rx /var/ftproot/
			请确保/etc/vsftpd/vsftpd.conf中已经启用了以下选项：
				anonymous_enable=YES
				local_enable=YES
				write_enable=YES
				anon_upload_enable=NO
				anon_mkdir_write_enable=NO
				chroot_local_user=YES
			而后添加以下选项：
				guest_enable=YES
				guest_username=vuser
			并确保pam_service_name选项的值如下所示：
				pam_service_name=vsftpd.mysql
	d) 启动vsftpd服务并查看端口开启情况
		service vsftpd start
		chkconfig vsftpd on
		ss -tnlp|grep 21
	e) 配置虚拟用户具有不同的访问权限
		vsftpd可以在配置文件目录中为每个用户提供单独的配置文件以定义其ftp服务访问权限，每个虚拟用户的配置文件名同虚拟用户的用户名。
		配置文件目录可以是任意未使用目录，只需要在vsfptd.conf中指定其路径及名称即可
		编辑vsftpd.conf文件，添加如下选项
			user_config_dir=/etc/vsftpd/vusers_config
		创建所需要的目录，并为虚拟用户提供配置文件
			mkdir /etc/vsftpd/vusers_config
			cd /etc/vsftpd/vusers_config
			touch tom jerry
		配置虚拟用户的访问权限
			虚拟用户对vsftpd服务的访问权限是通过匿名用户的相关指令进行的。
			比如，如果需要让tom用户具有上传文件的权限，可以修改/etc/vsftpd/vusers_config/tom文件，添加如下选项即可：
				anon_upload_enable={YES|NO}
				anon_mkdir_write_enable={YES|NO}
				anon_other_write_enable={YES|NO}

Linux下好用的下载工具：
	axel：可实现多线程下载，断点续传等功能，下载速度超快
	lftpget
	wget
	curl

第十一章 网络文件共享服务之samba
Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。
在此之前我们已经了解了NFS和FTP，NFS与samba一样，也是在网络中实现文件共享的一种实现，但不幸的是，其不支持windows平台，而本章要提到的samba是能够在任何支持SMB协议的主机之间共享文件的一种实现，当然也包括windows。

SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。
SMB协议是C/S型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。
通过设置“NetBIOS over TCP/IP”使得Samba不但能与局域网主机分享资源，还能与全世界的电脑分享资源。

Samba监听端口有：
	tcp的139，445号端口
	udp的137，138号端口

tcp端口相对应的服务是smbd服务，其作用是提供对服务器中文件、打印资源的共享访问
udp端口相对应的服务是nmbd服务，其作用是提供基于NetBIOS主机名称的解析

Samba服务脚本：
	/etc/rc.d/init.d/nmb
	/etc/rc.d/init.d/smb

Samba进程：
	nmbd：对应netbios
	smbd：对应cifs协议
	winbindd + ldap：对应Windows AD活动目录

Samba用户：
	帐号：都是系统用户，/etc/passwd
	密码：Samba服务自有密码文件，通过smbpasswd -a USERNAME命令设置

Samba安全级别：
	Samba服务器的安全级别有四个，分别是share，user，server，domain
	share：表示匿名访问
	user：表示基于本地的验证
	server：表示由另一台指定的服务器对用户身份进行认证
	domain：表示由域控进行身份验证

Samba配置文件：/etc/samba/smb.conf
	Samba主配置文件的配置内容默认包含三个部分，分别是[global]全局配置、[homes]宿主目录共享设置、[printers]打印机共享设置
	[global]全局配置的设置项对整个samba服务器都有效
	[homes]则用来设置Linux用户的默认共享，对应用户的宿主目录。当用户访问服务器中与自己用户名同名的共享目录时，通过验证后将会自动映射到该用户的宿主目录中

	具体配置参数：
		workgroup表示设置工作组名称；
		server string表示描述samba服务器；
		security表示设置安全级别，其值可为share、user、server、domain；
		passdb backend表示设置共享帐户文件的类型，其值可为tdbsam（tdb数据库文件）、ldapsam（LDAP目录认证）、smbpasswd（兼容旧版本samba密码文件）；
		comment表示设置对应共享目录的注释，说明信息，即文件共享名；
		browseable表示设置共享是否可见；
		writable表示设置目录是否可写
		path表示共享目录的路径；
		guest ok表示设置是否所有人均可访问共享目录；
		printable表示设置是否为打印机
	测试配置文件是否有语法错误，以及显示最终生效的配置：使用testparm命令
		testparm

web界面配置samba：
	samba-swat包提供了在web界面上配置samba的功能，其自带web服务，默认端口为901，通过xinetd来管理

Samba访问方式：作为客户端
	交互式数据访问：
		smbclient -L HOST -U USERNAME
		smbclient //SERVER/shared_name -U USERNAME
	基于挂载的方式访问：
		mount -t cifs //SERVER/shared_name -o username=USERNAME,password=PASSWORD

smbpasswd命令：
	-a Sys_User：添加系统用户为samba用户并为其设置密码
	-d：禁用用户帐号
	-e：启用用户帐号
	-x：删除用户帐号

Samba示例：
	#使用yum命令安装samba服务器:
	yum -y install samba-*
	#配置selinux安全机制(去除26行与29行的#号）:
	sed -i '26d' /etc/samba/smb.conf
	sed -i '25 a setsebool -P samba_domain_controller on' /etc/samba/smb.conf
	sed -i '29d' /etc/samba/smb.conf
	sed -i '28 a setsebool -P samba_enable_home_dirs on' /etc/samba/smb.conf
	#这两行生效后，自己的home目录就可以正常读写了。
	#如果想将/test目录设置成完全的共享就要改变文件目录的selunux：
	#chcon -t samba_share_t /test

	#设置共享类型，有匿名访问，有本地用户验证，默认为user用户验证：
	#                                   设置为匿名共享：
	#sed -i '101d' /etc/samba/smb.conf
	#sed -i '100 a security = share' /etc/samba/smb.conf
	#                                   设置为本地用户验证：
	#sed -i '101d' /etc/samba/smb.conf
	#sed -i '100 a security = user' /etc/samba/smb.conf
	#                              设置为另一台服务器进行远程验证：
	#sed -i '101d' /etc/samba/smb.conf
	#sed -i '100 a security = server' /etc/samba/smb.conf
	#                                   设置为域控验证：
	#sed -i '101d' /etc/samba/smb.conf
	#sed -i '100 a security = domain' /etc/samba/smb.conf
	#假设现在有一个文件夹为test，那么就像下面这样来设置共享：
	#设置共享的标识：
	echo '[test]' >> /etc/samba/smb.conf
	#设置共享的显示名，即在访问时看到的共享名，假设这里共享名为test：
	echo 'comment = test' >> /etc/samba/smb.conf
	#设置共享路径：
	echo 'path = /test' >> /etc/samba/smb.conf
	#设置共享是否可见：
	echo 'browseable = yes' >> /etc/samba/smb.conf
	#设置是否所有人均可访问：
	echo 'guest ok = yes' >> /etc/samba/smb.conf
	#设置目录是否可写：
	echo 'writable = yes' >> /etc/samba/smb.conf
	#设置是否允许匿名用户访问：
	echo 'public = yes' >> /etc/samba/smb.conf
	#设置可以写的用户或组：
	echo 'write list = root,@root' >> /etc/samba/smb.conf


	#限制访问端：
	#设置可以访问的用户或组：
	echo 'valid users = root,@root' >> /etc/samba/smb.conf
	#设置拒绝来自192.168.72.1的用户访问：
	echo 'hosts deny = 192.168.72.1' >> /etc/samba/smb.conf
	#设置允许来自192.168.72.2的用户访问：
	echo 'hosts allow = 192.168.72.2' >> /etc/samba/smb.conf

	#映射共享目录：
	#创建用户one：
	#useradd one
	#为one用户创建smb共享密码：
	#smbpasswd -a one
	#假设这里映射one用户为aaa用户，那么就要在/etc/samba/smbusers文件中添加如下内容：
	#echo 'one = aaa' >> /etc/samba/smbusers
	#在全局配置中添加如下内容：
	sed -i '244 a username map = /etc/samba/smbusers' /etc/samba/smb.conf

	#启动smb服务：
	#service smb start
	#重启smb服务：
	service smb restart
	#重新加载smb服务：
	#service smb reload
	#设置smb服务随系统启动而启动：
	chkconfig smb on

	#建立共享文件夹：
	mkdir /test

第十二章 http协议
12.1 http协议简介
	http（HyperText Transfer Protocol，超文本传输协议）是互联网上应用最为广泛的一种网络协议。所有的www文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext)。这成为HTTP超文本传输协议标准架构的发展根基。
	超文本就是带有超链接的文本，超链接就是基于一些链接实现文档间跳转的文本。

	http协议是一种无状态的协议（stateless）：
		服务器无法持续追踪访问者来源，为了解决此问题引入了cookie和session，实现追踪与保存用户的行为



12.2 http技术架构
	http是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。
	通过使用web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。
	这个客户端被称作用户代理（User Agent）。
	应答的服务器上存储着一些资源，比如HTML文件和图像，这个应答服务器被称作源服务器（Origin Server）。

	在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道。尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和基于它支持的层。事实上，HTTP可在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定其下层协议提供可靠的传输，任何能够提供这种保证的协议都可以被其使用。

	通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器向客户端发回一个状态行，比如“HTTP/1.1 200 OK”和响应的消息，消息的消息团体可能是请求的文件、错误消息或者其它一些信息。HTTP使用TCP而不是UDP的原因在于打开一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据和错误纠正。

	通过HTTP或者HTTPS协议请求的资源由统一资源标示符（Uniform Resource Identifiers）来标识。

12.3 http协议功能
	http协议是用于从www服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分以及哪些部分内容首先显示（如文本先于图形）等。

	http是客户端浏览器或其他程序与web服务器之间的应用层通信协议。在internet上的web服务器上存放的都是超文本信息，客户机需要通过http协议传输所要访问的超文本信息。http包含命令和传输信息，不仅可用于web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。

	我们在浏览器的地址栏里输入的网站地址叫做URL（Uniform Resource Locator，统一资源定位符）。就像每家每户都有一个门牌地址一样，每个网页也都有一个internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超链接时，URL就确定了林浏览的地址。浏览器通过HTTP将web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。

12.4 http协议版本
	超文本传输协议已经演化出了很多版本，它们中的大部分都是向下兼容的。在RFC 2145中描述了HTTP版本号的用法。客户端在请求的开始告诉服务器它采用的协议版本号，而后者则在响应中采用相同或者更早的协议版本。
	http协议的版本主要有以下这些：
	HTTP/0.9：最原始版本，功能简陋。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，所以客户端无法向服务器传递太多信息。
	HTTP/1.0：这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。支持MIME。
	HTTP/1.1：增加了缓存功能，引入了长连接（默认采用），能很好的配合代理服务器工作 ，支持以管理方式同时发送多个请求，以便降低线路负载，提高传输速度。
	HTTP/2.0：大幅度提升了web性能，减少网络延迟，通常用于https

	HTTP/1.1相较于 HTTP/1.0 协议的区别主要体现在：
		a) 缓存处理
		b) 带宽优化及网络连接的使用
		c) 错误通知的管理
		d) 消息在网络中的发送
		e) 互联网地址的维护
		f) 安全性及完整性

12.5 名词解释
	HTML：HyperText Mark Language，超文本标记语言

	URI：Uniform Resource Indentifier，统一资源标识符。用于定义全局范围内（包括但不仅限于互联网）去标记唯一的、定位一种资源访问路径的方式，或者命名方式，被称作统一资源标识符。这里的统一指的是路径格式上的统一。

	URL：Uniform Resource Location，统一资源定位符，是URI的一个子集，用于描述在互联网上互联网资源的统一表示格式（protocol://host:port/path/to/file）
	URL基本语法：
		<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>

		params：参数，如http://www.idfsoft.com/bbs/index.html;gender=f，这里的gender=f就是一个参数
		query：传递给关系型数据库页面的特定行为。如http://www.idfsoft.com/bbs/item.php?username=tom&title=abc，这个URL表示要查询的是username=name并且title=abc的条目
		frag：用来定义一个较大页面中的某一个位置，而不是页面的开始处。说白点就是位置锚定

	URN：Uniform Resource Naming，统一资源命名符，也是URI的一个子集

	MIME：Multipurpose Internet Mail Extension，多用途互联网邮件扩展。
	MIME可以将非文本数据在传输前重新编码为文本格式再传输给对方，接收方能够用相反的方式将其重新还原为原来的格式，还能够调用相应的程序来打开此文件

	http事务：http协议的一次请求（request）和响应（response）的过程就称之为http事务

	动态网页：包含静态内容和动态内容（动态内容需要执行） 
	服务器端存储的不是HTML文档，而是编程语言开发的脚本，脚本接受参数之后在服务器端运行一次，运行完成之后会生成HTML格式的文档，并把生成好的HTML文档传给客户端

	Web资源：web resource。
		静态文件：.jpg，.gif，.html，.txt，.js，.css，.mp3，.avi
		动态文件：.php，.jsp

	PV：Page View，打开了多少页面
	UV：User View，独立IP量

12.6 http协议报文
	http协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URL、协议版本以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，响应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。

	http协议的报文有请求报文和响应报文2种，其语法样式如下：
		请求报文语法：
		<method> <request-URL> <version>
		<headers>

		<entity-body>
                
		响应报文语法：
		<version> <status> <reason-phrass>
		<headers>

		<entity-body>

	报文的第一行通常称作报文“起始行（start line）”，后面的标签格式的内容称作首部域（Header Field），每个首部域由名称（name）和值（value）组成，中间用逗号分隔。
	另外，响应报文通常还有一个称作Body的信息主体，即响应给客户端的内容。

	method：请求方法，标明客户端希望服务器对资源执行的动作，常见的有以下几种：
		GET：从服务器获取一个资源
		HEAD：只从服务器获取文档的响应首部，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的
		POST：向服务器发送要处理的数据。服务器端通常通过提供一个表单，客户端填入数据时会把内容放入entity-body中提交提交给服务器端
		PUT：将请求的主体部分存储在服务器上。说白点就是上传数据
		DELETE：请求删除服务器上指定的文档
		TRACE：追踪请求到达服务器中间经过的代理服务器
		OPTIONS：请求服务器返回对指定资源支持使用的请求方法
	version：http的协议版本，格式如HTTP/<major>.<minor>
	status：响应状态码，用于标记请求处理过程中发生的情况，常见的响应状态码有以下几种：
		1xx：100-101，纯信息提示
			100：服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求，响应状态码为"Continue"
			101：服务器转换协议，服务器将遵从客户的请求转换到另外一种协议，响应状态码为"Switching Protocols"
		2XX：200-206，“成功”类的信息
			200：请求资源正常。请求的所有数据通过响应报文的entity-body部分发送，响应状态码为“OK”
			201：请求被创建完成，同时新的资源被创建，响应状态码为"Created"
			202：供处理的请求已被接受，但处理未完成，响应状态码为"Accepted"
			203：文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝，响应状态码为"Non-authoritative information"
			204：没有新文档。浏览器应该继续显示原来的文档。响应状态码为"No Content"
			205：没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容，响应状态码为"Reset Content"
			206：客户发送了一个带有Range头的GET请求，服务器完成了它
		3XX：300-305，“重定向”类的信息
			301：永久重定向，响应状态码为“Moved Permanently”
				请求的URL指向的资源已经被删除，但在响应报文中通过首部Location指明了资源现在所处的新位置，客户端需要请求新位置的资源
			302：临时重定向，我这里正忙，你要的资源在另一个地方也有，你先去那里要，响应状态码为“Found”
				与301相似，但在响应报文中通过Location指明资源现在所处的临时新位置
			304：客户端发出了条件式请求，但服务器端发现客户端请求的资源已被客户端缓存过且未发生改变，让客户端直接到缓存里去取。响应状态码为“Not Modified”
		4XX：400-415，“客户端错误”类的信息
			400：由于客户端请求有语法错误，不能被服务器所理解，响应状态码为“Bad Request”
			401：需要输入帐号和密码认证方能访问资源，响应状态码为“Unauthorized”
			403：请求被禁止，响应状态码为“Forbidden”
			404：服务器无法找到客户端请求的资源，响应状态码为“Not Found”
		5XX：500-505，“服务端错误”类的信息
			500：服务器内部错误，响应状态码为“Internal Server Error”
			502：代理服务器从后端服务器收到了一条伪响应，响应状态码为“Bad Gateway”
			503：服务器当前不能够处理客户端的请求，在一段时间之后，响应状态码为“Service”
	reason-phrass：解释status状态码的情况，你成功了，是什么成功了，你失败了，是什么失败了，是获取文件成功/失败还是上传文件成功/失败等等。
	headers：用来标记请求或响应的属性
		每个请求或响应报文可包含任意个首部；
		每个首部都有首部名称，后面跟一个冒号，而后跟上一个可选空格，接着是一个值

		格式：Name: Value

		首部的分类：
			通用首部：可用在请求报文和响应报文中，常见的内容如下：
				Date：报文的创建时间
				Connection：连接状态，如keep-alive，close等
				Via：显示报文经过的中间节点
				Cache-Control：控制缓存的生效方法和机制
			请求首部：只能在请求报文中使用，常见的内容如下：
				Accept：通知服务器客户端可以接受的媒体类型
				Accept-Charset：通知服务器客户端可以接受的字符集
				Accept-Encoding：通知服务器客户端可以接受的内容编码格式，如gzip
				Accept-Language：通知服务器客户端可以接受的语言
				Client-IP：客户端的IP
				Host：请求的服务器名称和端口号
				Referer：包含当前正在请求的资源的上一级资源
				User-Agent：客户端代理

				条件式请求首部：
					Expect：期望服务器端发什么信息
					If-Modified-Since：自从此处指定的时间之后请求的资源是否发生修改
					If-Unmodified-Since：自从此处指定的时间之后请求的资源是否未发生修改
					If-None-Match：本地缓存中存储的文档的ETag标签是否与服务器文档的ETag不匹配
					If-Match：本地缓存中存储的文档的Etag是否与服务器文档的Etag匹配
				安全请求首部：
					Authorization：向服务器发送认证信息，如帐号和密码
					Cookie/Cookie2：客户端向服务器发送cookie
				代理请求首部：
					Proxy-Authorization：向代理服务器认证
			响应首部：只能在响应报文中使用
				信息性：
					Age：响应持续时长
					Server：服务器程序软件名称和版本
				协商首部：某资源有多种表示方法时使用
					Accept-Ranges：服务器可接受的请求范围类型
					Vary：服务器查看的其它首部列表
				安全响应首部：
					Set-Cookie：向客户端设置cookie
					Set-Cookie2：向客户端设置cookie2
					WWW-Authenticate：来自服务器的对客户端的质询认证表单
			实体首部：标识实体的相关信息
				Allow：列出对此实体可使用的请求方法
				Location：告诉客户端真正的实体位于何处
				Content-Encoding：内容的编码格式
				Content-Language：内容使用的语言
				Content-Length：主体的长度
				Content-Location：实体真正所处的位置
				Content-Type：主体的对象类型
				缓存相关：
					ETag：实体的扩展标签
					Expires：实体的过期时间
					Last-Modified：最后一次修改的时间
			扩展首部
	entity-body：请求时附加的数据或响应时附加的数据，有可能为空

	请求报文示例：
		GET / HTTP/1.1
		HOST：www.baidu.com
		Connection：keep-alive

	响应报文示例：
		HTTP/1.1 200 OK
		X-Powered-By：PHP/5.2.17
		Vary：Accept-Encoding,Cookie,User-Agent
		Cache-Control：max-age=3,must-revalidate
		Content-Encoding：gzip
		Content-Length：6931

12.7 http周边
	常见的协议查看、分析的工具：
		tcpdump
		tshark
		wireshark

	常见的http服务器程序：
		httpd（apache）
		nginx
		lighttpd
		应用程序服务器：可以处理动态文件
			IIS
			tomcat，jetty，jboss，resin
			webshpere，weblogic，oc4j

	常用的http压力测试工具：
		ab：
			语法：ab [options] URL
			-n：总的请求数
			-c：模拟的并发数
			-k：以持久连接模式测试
		webbench
		http_load
		jmeter
		loadrunner
		tcpcopy

	ulimit -n #：调整当前用户所能够同时打开的文件数

	web服务器资源路径映射方式：
		docroot
		alias
		虚拟主机docroot
		用户家目录docroot

	并发访问响应模型（Web I/O）：此处假定每个进程内只有一个线程
		单进程I/O结构：启动一个进程处理请求，而且一次只处理一个，多个请求被串行响应
		多进程I/O结构：并行启动多个进程，每个进程响应一个请求
		复用I/O结构：一个进程响应多个请求
			多线程模型：一个进程生成多个线程，每个线程响应一个用户请求
			事件驱动
		复用的多进程I/O结构：启动多个（m）进程，每个进程响应n个请求


12.8 https
	https其实就是将ssl或tls应用于http协议的结果，https监听于tcp/443端口

	ssl会话的简化过程如下：
	（1）客户端发送可供选择的加密方式，并向服务器请求证书
	（2）服务器端发送证书以及选定的加密方式给客户端
	（3）客户端取得证书并进行证书验证
		如果信任给其发证书的CA：
		a) 验证证书来源的合法性：用CA的公钥解密证书上的数字签名
		b) 验证证书内容的合法性：完整性验证
		c) 检查证书的有效期限
		d) 检查证书是否被吊销
		e) 证书中拥有者的名字，与访问的目标主机要一致
	（4）客户端生成临时会话密钥（对称密钥），并使用服务器端的公钥加密此数据发送给服务器，完成密钥交换
	（5）服务器用密钥加密用户请求的资源，响应给客户端
	注意：SSL会话是基于IP地址创建，所以单IP的主机上，仅可以使用一个https虚拟主机

	WEB服务器的主要操作：
		建立连接——接受或拒绝客户端连接请求；
		接收请求——通过网络读取HTTP请求报文；
		处理请求——解析请求报文并做出相应的动作；
		访问资源——访问请求报文中相应的资源；
		构建响应——使用正确的首部生成HTTP响应报文；
		发送响应——向客户端发送生成的响应报文；
		记录日志——当已经完成的HTTP事务记录进日志文件


第十三章 httpd详解
13.1 httpd简介
	httpd是Apache超文本传输协议（HTTP）服务器的主程序。被设计为一个独立运行的后台进程，它会建立一个处理请求的子进程或线程的池。

	通常，httpd不应该被直接调用，而应该在类Unix系统中由apachectl调用，在Windows中作为服务运行。

13.2 httpd版本
	本文主要介绍httpd的两大版本，httpd-2.2和httpd-2.4。
	CentOS6系列的版本默认提供的是httpd-2.2版本的rpm包，而CentOS7默认提供的是httpd-2.4版本的rpm包

13.2.1 httpd的特性
	httpd有很多特性，下面就分别来说说httpd-2.2版本和httpd-2.4版本各自的特性。
	httpd-2.2的特性：
	a) 事先创建进程
	b) 按需维持适当的进程
	c) 模块化设计，核心比较小，各种功能通过模块添加（包括PHP），支持运行时配置，支持单独编译模块
	d) 支持多种方式的虚拟主机配置，如基于ip的虚拟主机，基于端口的虚拟主机，基于域名的虚拟主机等
	e) 支持https协议（通过mod_ssl模块实现）
	f) 支持用户认证
	g) 支持基于IP或域名的ACL访问控制机制
	h) 支持每目录的访问控制（用户访问默认主页时不需要提供用户名和密码，但是用户访问某特定目录时需要提供用户名和密码）
	i) 支持URL重写
	j) 支持MPM（Multi Path Modules，多处理模块）。用于定义httpd的工作模型（单进程、单进程多线程、多进程、多进程单线程、多进程多线程）
		prefork：多进程模型，预先生成进程，一个请求用一个进程响应
			一个主进程负责生成n个子进程，子进程也称为工作进程；
			每个子进程处理一个用户请求，即使没有用户请求，也会预先生成多个空闲进程，随时等待请求到达，最大不会超过1024个
		worker：基于线程工作，一个请求用一个线程响应（启动多个进程，每个进程生成多个线程）
		event：基于事件的驱动，一个进程处理多个请求

	httpd-2.4的新特性：
	a) MPM支持运行DSO机制（Dynamic Share Object，模块的动态装/卸载机制），以模块形式按需加载
	b) 支持event MPM，eventMPM模块生产环境可用
	c) 支持异步读写
	d) 支持每个模块及每个目录分别使用各自的日志级别
	e) 每个请求相关的专业配置，使用<If>来配置
	f) 增强版的表达式分析器
	g) 支持毫秒级的keepalive timeout
	h) 基于FQDN的虚拟主机不再需要NameVirtualHost指令
	i) 支持用户自定义变量
	j) 支持新的指令（AllowOverrideList）
	k) 降低对内存的消耗

13.2.2 httpd-2.4新增的模块
	httpd-2.4在之前的版本基础上新增了几大模块，下面就几个常用的来介绍一下。
	mod_proxy_fcgi：反向代理时支持apache服务器后端协议的模块
	mod_ratelimit：提供速率限制功能的模块
	mod_remoteip：基于ip的访问控制机制被改变，不再支持使用Order，Deny，Allow来做基于IP的访问控制

13.3 httpd基础
13.3.1 httpd自带的工具程序
	htpasswd：basic认证基于文件实现时，用到的帐号密码生成工具
	apachectl：httpd自带的服务控制脚本，支持start，stop，restart
	apxs：由httpd-devel包提供的，扩展httpd使用第三方模块的工具
	rotatelogs：日志滚动工具
		access.log -->
		access.log,access.1.log
		access.log,access.1.log,access.2.log
	suexec：访问某些有特殊权限配置的资源时，临时切换至指定用户运行的工具
	ab：apache benchmark，httpd的压力测试工具

13.3.2 rpm包安装的httpd程序环境
	httpd-2.2版本程序环境：
		配置文件：
			/etc/httpd/conf/httpd.conf
			/etc/httpd/conf.d/*.conf
		配置文件的组成：grep "Section" /etc/httpd/conf/httpd.conf
			### Section 1: Global Environment
			### Section 2: 'Main' server configuration
			### Section 3: Virtual Hosts
			配置格式：directive value
				directive：指令，不区分字符大小写
				value：为路径时，取决于文件系统
		服务脚本：
			/etc/rc.d/init.d/httpd
		服务脚本的配置文件：
			/etc/sysconfig/httpd
		主程序文件：
			/usr/sbin/httpd
			/usr/sbin/httpd.event
			/usr/sbin/httpd.worker
		日志文件目录：
			/var/log/httpd/
				access.log：访问日志
				error_log：错误日志
		站点文档目录：
			/var/www/html/
		模块文件路径：
			/usr/lib64/httpd/modules/

	httpd-2.4版本程序环境：
		主配置文件：/etc/httpd/conf/httpd.conf
		模块配置文件：/etc/httpd/conf.modules.d/*.conf
		辅助配置文件：/etc/httpd/conf.d/*.conf

		mpm：以DSO机制提供，配置文件为/etc/httpd/conf.modules.d/00-mpm.conf

13.3.3 web相关的命令
	curl命令：
		curl是基于URL语法在命令行方式下工作的文件传输工具，它支持FTP，FTPS，HTTP，HTTPS，GOPHER，TELNET，DICT，FILE及LDAP等协议。
		curl支持：
			https认证
			http的POST/PUT等方法
			ftp上传
			kerberos认证
			http上传
			代理服务器
			cookies
			用户名/密码认证
			下载文件断点续传
			socks5代理服务器
			通过http代理服务器上传文件到ftp服务器
		语法：curl [options] [URL ...]
		常用的options：
			-A/--user-agent <string>：设置用户代理发送给服务器
			-basic：使用Http基本认证
			--tcp-nodelay：使用TCP_NODELAY选项
			-e/--referer <URL>：来源网址
			--cacert <file>：CA证书（SSL）
			--compressed：要求返回时压缩的格式
			-H/--header <line>：自定义请求首部信息传递给服务器
			-I/--head：只显示响应报文首部信息
			--limit-rate <rate>：设置传输速度
			-u/--user <user[:password]>：设置服务器的用户和密码
			-0/--http1：使用http 1.0版本，默认使用1.1版本。这个选项是数字0而不是字母o

	elinks命令：
		语法：elinks [options] [URL ...]
		常用的options：
			-dump：不进入交互式模式，而直接将URL的内容输出至标准输出

	httpd命令：
		语法：httpd [options]
		常用的options：
			-l：查看静态编译的模块，列出核心中编译了哪些模块。它不会列出使用LoadModule指令动态加载的模块
			-M：输出一个已经启用的模块列表，包括静态编译在服务器中的模块和作为DSO动态加载的模块
			-v：显示httpd的版本，然后退出
			-V：显示httpd和apr/apr-util的版本和编译参数，然后退出
			-X：以调试模式运行httpd。仅启动一个工作进程，并且服务器不与控制台脱离


13.4 编译安装httpd-2.4
	httpd依赖于apr-1.4+，apr-util-1.4+，[apr-icon]
	apr：apache portable runtime
	CentOS6提供的apr是1.3.9版本，而apr-util也是1.3.9版本，所以想在CentOS6上安装httpd-2.4版本时需要先安装apr-1.4+和apr-util-1.4+，而在CentOS7中则不用另行安装

	httpd-2.4编译安装步骤：
	a) 安装开发环境（yum groupinstall）
	b) 下载并安装apr-1.4+和apr-util-1.4+。此步骤仅需在CentOS6系列上执行，CentOS7无需执行此步
		cd /usr/src/
		wget http://mirrors.hust.edu.cn/apache//apr/apr-1.5.2.tar.bz2
		wget https://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-util-1.5.4.tar.bz2
		tar xvf apr-1.5.2.tar.bz2
		tar xvf apr-util-1.5.4.tar.bz2
		cd apr-1.5.2
		./configure --prefix=/usr/local/apr
		make && make install
		cd ../apr-util-1.5.4
		./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr
		make && make install
	c) 编译安装httpd
		groupadd -r apache
		useradd -r -g apache apache
		yum -y install openssl-devel pcre-devel
		./configure --prefix=/usr/local/apache --sysconfdir=/etc/httpd24 --enable-so --enable-ssl --enable-cgi --enable-rewrite --with-zlib --with-pcre --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util/ --enable-modules=most --enable-mpms-shared=all --with-mpm=prefork
		make && make install

13.5 httpd常用配置
	httpd-2.2常用配置：
	修改监听的IP和端口：
		Listen [IP:]PORT
		省略IP表示监听所有地址。Listen可重复出现多次

	持久连接：即长连接
		Persistent Connection：连接建立，每个资源获取完成后不会立即断开连接，而是继续等待其它的请求完成
			如何断开？
				数量限制：默认获取100个资源后会自动断开连接
				时间限制：可配置，对于并发很大的服务器来说，此值不能设定太大
			副作用：对于并发访问量较大的服务器，持久连接功能会使有些请求得不到响应
			折衷：使用较短的持久连接时间。httpd-2.4支持毫秒级持久时间
		KeepAlive ｛On | Off｝：设定是否启用持久连接
		MaxKeepAliveRequests 100：设定最大允许获取的资源数，当达到些设定值时将自动断开连接
		KeepAliveTimeout 15：设定时间限制，当达到些时间限制时将自动断开连接

		测试持久连接：
			telnet HOST PORT                # telnet 192.168.1.1 80
			GET /URL HTTP/1.1              # GET /index.html HTTP/1.1
			Host: HOSTNAME or IP        # Host: 192.168.1.1

	MPM：Multi Path Modules，多处理模块。用于定义httpd的工作模型（单进程、单进程多线程、多进程、多进程单线程、多进程多线程）
		httpd-2.2不支持同时编译多个模块，所以只能编译时选定一个
		rpm安装的包提供了三个二进制程序文件，分别用于实现对不同MPM机制的支持。确认方法：
			ps aux |grep httpd
		默认为/usr/sbin/httpd，其使用prefork
		更换使用的httpd程序：编辑/etc/sysconfig/httpd文件，并重启服务使之生效
			HTTPD=｛httpd | httpd.worker | httpd.event｝
		配置MPM：编辑主配置文件/etc/httpd/conf/httpd.conf
		prefork的配置：
			StartServers：服务启动时启动的服务器进程数（提供服务的子进程数，不包含主进程）
			MinSpareServers：最少空闲进程数
			MaxSpareServers：最大空闲进程数
			ServerLimit：为MaxClients所准备的在其服务生命周期内所允许的进程数量最大值
			MaxClients：最大并发请求数
			MaxRequestsPerChild：一个服务器进程最多能够响应多少次的请求
		worker的配置：
			StartServers：服务启动时启动的服务器进程数（提供服务的子进程数，不包含主进程）
			MaxClients：服务端最多启动的线程数量
			MinSpareThreads：最少空闲线程数
			MaxSpareThreads：最多空闲线程数
			ThreadsPerChild：每个进程所能够启动的线程数
			MaxRequestsPerChild：每个线程所能够响应的最大请求数量，0表示无限制

	DSO：Dynamic Share Object，模块的动态装/卸载机制
		配置指令实现模块加载：
			LoadModule <mod_name> <mod_path>
			模块路径（mod_path）可使用相对路径：
				相对于ServerRoot（/etc/httpd）指向的路径而言
					/etc/httpd/modules   -->  /usr/lib64/httpd/modules

	定义“Main”server的文档页面路径，DocumentRoot
		文档路径映射：
			DocumentRoot指向的路径为URL路径的起始位置
				DocumentRoot "/var/www/html"
					test/index.html  -->  http://HOST:PORT/test/index.html

	站点访问控制：
		可基于两种类型的路径指明对哪些资源进行访问控制：
			针对文件系统路径：
				<Directory ""> </Directory>
				<File ""> </File>
				<FileMatch ""> </FileMatch>
			针对URL路径：
				<Location ""> </Location>
				<LocationMatch ""> </LocationMatch>
		访问控制机制：
			基于来源地址
			基于帐号

	Directory中“基于来源地址”实现访问控制：httpd-2.2版本
		a) Options
			所有可用特性：Indexes  Includes  FollowSymLinks  SymLinksifOwnerMatch  ExecCGI  MultiViews
				Indexes：索引，当不指定要访问的页面具体路径而又没有默认主页（index.html）时，以链接形式列出根（默认为/var/www/html）下的所有内容
				FollowSymLinks：允许跟踪符号链接文件
		b) 基于来源地址的访问控制机制
			Order：检查次序
				Order allow,deny    先允许后拒绝。默认所有都拒绝，只有明确允许的才允许访问
				Order deny,allow    先拒绝后允许。默认所有都允许，只有明确拒绝的才拒绝访问
			Allow from 来源地址
			Deny from 来源地址

			来源地址可以为：
				IP：如192.168.1.1
				NetAddr：
					172.16
					172.16.0.0
					172.16.0.0/16
					172.16.0.0/255.255.0.0
				FQDN：可以是完整的主机名，也可以是一个域名，如*.idfsoft.com
				All

	基于用户的访问控制：
		认证质询：此处是一个响应报文
			WWW-Authenticate：响应码为401，拒绝客户端请求，并说明要求客户提供帐号和密码
		认证：此处是一个请求报文
			Authorization：客户端用户填入帐号和密码后再次发送请求报文，认证通过，则服务器发送响应的资源
			认证类型：
				basic：明文
				digest：消息摘要，经过MD5加密
		安全域：需要用户认证后才能访问的路径称之为安全域
			应该通过名称对其进行标识，并用于告知用户认证的原因
		用户的帐号和密码存储于何处：
			虚拟帐号：仅用于访问某服务时用到的认证标识
			存储机制：
				文本文件
				SQL数据库
				ldap
				nis
		basic认证：基于文本文件的存储机制
			a) 定义安全域
			<Directory "">
				Options None
				AllowOverride None
				AuthType Basic
				AuthName "String"
				AuthUserFile "/PATH/TO/HTTPD_USER_PASSWD_FILE"
				Require user username1 username2 ...     #只允许帐号文件中指定的用户登录访问
			</Directory>
			允许帐号文件中的所有用户登录访问：
				在<Directory> </Directory>之间添加Require valid-user
			b) 提供帐号和密码存储（使用htpasswd命令）
				htpasswd [options] passwordfile username
				常用的options：
					-c：自动创建passwordfile，因此，仅应该在添加第一个用户时使用
					-m /path/to/passwordfile：md5加密用户密码
					-s：sha1加密用户密码
					-D：删除指定用户
			c) 实现基于组进行认证
			<Directory "">
				Options None
				AllowOverride None
				AuthType Basic
				AuthName "String"
				AuthUserFile "/PATH/TO/HTTPD_USER_PASSWD_FILE"
				AuthGroupFile "/PATH/TO/HTTPD_GROUP_FILE"
				Require group GROUP1 GROUP2 ...
			</Directory>
			要提供用户帐号文件和组文件：
				组文件：只能手动定义，每一行定义一组。格式如下：
					GROUP_NAME：user1 user2 user3 ...
				在组文件中的user必须在帐号文件中存在。

	定义默认主页面：
		DirectoryIndex index.html index.html.var

	日志设定：
		定义日志格式：LogFormat 
			LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"" combined
			LogFormat "%h %l %u %t \"%r\" %>s %b" common
			LogFormat "%{Referer}i -> %U" referer
			LogFormat "%{User-agent}i" agent
			常用的日志格式定义宏：详情请看http://httpd.apache.org/docs/2.2/mod/mod_log_config.html 官方文档
				%h：客户端IP地址
				%l：小写的L，远程登录的用户名，Remote logname (from identd,if supplied). -表示为空
				%u：远程用户。Remote user, (from auth; may be bogus if return status (%s) is 401)
				%t：服务器收到请求的时间
				%r：请求报文的首行信息（请求的方法，URL，协议版本）
				%>s：响应状态码
				%b：响应报文的大小，不包含响应报文首部，单位是字节
				%{Referer}i：请求报文当中"referer"首部的值。当前资源的访问入口，即从哪个页面中的超链接跳转而来
				%{User-Agent}i：请求报文当中"User-Agent"首部的值。即发出请求用到的应用程序                                        
		错误日志：
			Errorlog logs/error_log
			LogLevel <日志级别>    #默认是warn级别
				日志级别有以下这些：从低到高，日志级别越低，记录越详细
				debug
				info
				notice
				warn
				error
				crit
				alert
				emerg
		访问日志：
			CustomLog logs/access_log combined

	路径别名：把一个URL映射至别的路径上
		Alias /URL/ "/PATH/TO/SOMEDIR/"
		如：Alias /bbs/ "/bbs/htdocs"

	设定默认字符集：
		AddDefaultCharset UTF-8

	虚拟主机：
		有三种实现方案：
			基于ip：为每个虚拟主机准备至少一个ip地址
			基于port：为每个虚拟主机准备至少一个专用port，实践中很少使用
			基于域名：为每个虚拟主机准备至少一个专用域名
				需要将NameVirtualHost的注释去掉
			可混合使用上述三种方式中任意方式
		注意：一般虚拟主机莫与中心主机混用，所以，要使用虚拟主机，必须先禁用中心主机
			禁用中心主机：注释DocumentRoot
		每个虚拟主机都有专用配置：还可以在虚拟主机中通过Directory进行访问控制
		<VirtualHost *:80>    #此处的*可以换成指定的IP地址
			ServerAdmin webmaster@dummy-host.example.com
			DocumentRoot /www/docs/dummy-host.example.com
			ServerName dummy-host.example.com
			ErrorLog logs/dummy-host.example.com-error_log
			CustomLog logs/dummy-host.example.com-access_log common
		</VirtualHost>

	内置的status页面：可以查看服务器的状态
		<Location /server-status>
			SetHandler server-status
			Order deny,allow
			Deny from all
			Allow from .example.com
		</Location>

	使用mod_deflate模块压缩页面优化传输速度：适用于httpd-2.2版本
		适用场景：
			a) 节约带宽，额外消耗CPU，同时，可能有些较老浏览器不支持
			b) 压缩适于压缩的资源，例如文本文件
		方法：
			a) 编辑主配置文件/etc/httpd/conf/httpd.conf，查找mod_deflate.so，将其前面的注释去掉，启用mod_deflate模块
			b) 将以下内容添加至主配置文件：
				SetOutputFilter DEFLATE        #调用DEFLATE输出过滤器
				# mod_deflate configuration

				# Restrict compression to these MIME types    对下面指定的类型进行压缩
				AddOutputFilterByType DEFLATE text/plain
				AddOutputFilterByType DEFLATE text/html
				AddOutputFilterByType DEFLATE application/xhtml+xml
				AddOutputFilterByType DEFLATE text/xml
				AddOutputFilterByType DEFLATE application/xml
				AddOutputFilterByType DEFLATE application/x-javascript
				AddOutputFilterByType DEFLATE text/javascript
				AddOutputFilterByType DEFLATE text/css

				# Level of compression （Highest 9 - Lowest 1）    设定压缩比率
				DeflateCompressionLevel 9

				# Netscape 4.x has some problems.    根据首部的User-Agent基于正则模式匹配浏览器类型和版本
				BrowserMatch ^Mozilla/4 gzip-only-text/html        #浏览器是Mozilla/4时，用gzip压缩，但只压缩text/html格式的文档

				# Netscape 4.06-4.08 have some more problems    根据首部的User-Agent基于正则模式匹配浏览器类型和版本
				BrowserMatch ^Mozilla/4\.0[678] no-gzip                #浏览器是Mozilla的4.0、4.6、4.7或4.8版本时不压缩

				# MSIE masquerades as Netscape, but it is fine    根据首部的User-Agent基于正则模式匹配浏览器类型和版本
				BrowserMatch \bMSI[E] !no-gzip !gzip-only-text/html    #浏览器是IE6.0之前的版本时，不压缩，若要压缩则只用gzip压缩text/html格式的文档

	配置httpd支持https：
		a) 为服务器申请数字证书
			测试：通过私建CA发证书
				创建私有CA
				在服务器创建证书签署请求
				CA签证
		b) 配置httpd支持使用ssl，及使用的证书
			yum -y install mod_ssl
			配置文件：/etc/httpd/conf.d/ssl.conf
				DocumentRoot
				ServerName
				SSLCertificateFile
				SSLCertificateKeyFile
		c) 测试基于https访问相应的主机
			openssl s_client [-connect host:port] [-cert filename] [-CApath directory] [-CAfile filename]

	httpd-2.4常用配置：
		切换使用MPM（编辑/etc/httpd/conf.modules.d/00-mpm.conf文件）：
			LoadModule mpm_NAME_module modules/mod_mpm_NAME.so
				NAME：有三种，分别为prefork，event，worker

		修改“Main" Server的DocumentRoot

		基于IP的访问控制法则：
			允许所有主机访问： Require all granted
			拒绝所有主机访问： Require all deny

			控制特定IP访问：
				Require ip IPADDR：授权指定来源地址的主机访问
				Require not ip IPADDR：拒绝指定来源地址的主机访问
				IPADDR的类型：
					IP：192.168.1.1
					Network/mask：192.168.1.0/255.255.255.0
					Network/Length：192.168.1.0/24
					Net：192.168
			控制特定主机（HOSTNAME）访问：
				Require host HOSTNAME
				Require not host HOSTNAME
				HOSTNAME的类型：
					FQDN：特定主机的全名
					DOMAIN：指定域内的所有主机
			注意：httpd-2.4版本默认是拒绝所有主机访问的，所以安装以后必须做显示授权访问
			示例：
				<RequireAll>
					Require not ip 192.168.1.20
					Require all granted
				</RequireAll>

		虚拟主机：
			基于IP、PORT和域名都支持
			基于域名的不再需要NameVirtualHost指令

		ssl：
			启用模块：编辑/etc/httpd/conf.modules.d/00-base.conf文件，添加下面这行，如果已经有了但是注释了，则取消注释即可
				LoadModule ssl_module modules/mod_ssl.so

		服务脚本：
			CentOS6编译安装的服务脚本：apachectl {start | stop | restart}
			CentOS7的服务脚本：httpd.service，使用systemctl控制